[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ADSL GIScience and Geodatabases",
    "section": "",
    "text": "Welcome",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "simple-features.html",
    "href": "simple-features.html",
    "title": "Simple Features",
    "section": "",
    "text": "Simple feature standard",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#simple-feature-standard",
    "href": "simple-features.html#simple-feature-standard",
    "title": "Simple Features",
    "section": "",
    "text": "Simple features is an open standard (ISO 19125-1:2004) developed and endorsed by the Open Geospatial Consortium (OGC)\nThe standard is widely implemented in spatial databases (such as PostGIS), desktop GIS (e.g., ArcGIS, QGIS), programming languages (R, Python) and forms the vector data basis for libraries such as GDAL.",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#what-is-a-feature",
    "href": "simple-features.html#what-is-a-feature",
    "title": "Simple Features",
    "section": "What is a feature?",
    "text": "What is a feature?\nThe standard says:\n\nA simple feature is defined [‚Ä¶] to have both spatial and non-spatial attributes. Spatial attributes are geometry valued, and simple features are based on 2D geometry with linear interpolation between vertices.‚Äù\n\n\nA feature is thought of as a thing, or an object in the real world, such as a building or a tree.\nFeatures have:\n\na geometry describing where on Earth the feature is located\nattributes, which describe other properties.\n\nFor example:\n\nThe geometry of a tree can be the delineation of its crown, of its stem, or the point indicating its center\nattributes (properties) may include its height, color, diameter at breast height at a particular date, and so on",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#simple-feature-model",
    "href": "simple-features.html#simple-feature-model",
    "title": "Simple Features",
    "section": "Simple Feature Model",
    "text": "Simple Feature Model\n\nSimple features is a hierarchical data model that represents a wide range of geometry types.\nAll geometries are composed of points in a 2-, 3- or 4-dimensional space\nOf 18 geometry types supported by the specification, only the following seven (see Figure¬†1.1 and Table¬†1.1) are used in the vast majority of geographic research:\n\nThree basic types: points, linestrings, polygons\nThree composite types: mutlipoints, multilinestrings, multipolygons\nOne special case: geometrycollection (which can be a conglomarate of all the afore mentioned)\n\nThese seven core geometry types are fully supported by the R package sf (Pebesma 2018)\n\n\n\n\n\n\n\nFigure¬†1.1: Image source: Dorman (2023)\n\n\n\n\n\n\n\nTable¬†1.1: Source: Pebesma (2018)\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n# of Dimension\n\n\n\n\nPOINT\nzero-dimensional geometry containing a single point\n0\n\n\nLINESTRING\nsequence of points connected by straight1 line pieces\n1\n\n\nPOLYGON\nsequence of points form a closed2 ring3\n2\n\n\nMULTIPOINT\nset of points\n0\n\n\nMULTILINESTRING\nset of linestrings\n1\n\n\nMULTIPOLYGON\nset of polygons\n2\n\n\nGEOMETRYCOLLECTION\nset of geometries of any of the above types\nNA",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#simple-features-in-r",
    "href": "simple-features.html#simple-features-in-r",
    "title": "Simple Features",
    "section": "Simple features in R",
    "text": "Simple features in R\nSimple Features in R is modelled in three levels:\n\nSimple feature geometries (sfg): Individual Simple Feature objects\nSimple Feature geometry columns (sfc): A list column of sfgs\nSimple Features (with attributes): A sfc with attributes, i.e.¬†additional columns",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#sfg-simple-feature-geometry",
    "href": "simple-features.html#sfg-simple-feature-geometry",
    "title": "Simple Features",
    "section": "sfg: simple feature geometry",
    "text": "sfg: simple feature geometry\n\nSimple feature geometries are implemented as R native data, using the following rules:\n\na single POINT is a numeric vector\na set of points, e.g.¬†in a LINESTRING or ring of a POLYGON is a matrix, each row containing a point\nany other set is a list\n\n\n(however, creator functions are rarely used in practice, since we typically bulk read and write spatial data. They are useful for illustration)\n\nPoints\n\nlibrary(sf)\nfracht &lt;- st_point(c(2685374, 1256519))\n\nfracht\n\n\nplot(fracht)\n\n\n\n\n\n\n\n\n\n\nLinestrings\n\ncoords &lt;- c(\n  2684336, 1255553, \n  2682705, 1258929\n  ) |&gt; \n  matrix(ncol = 2, byrow = TRUE)\n\ncoords\n\n        [,1]    [,2]\n[1,] 2684336 1255553\n[2,] 2682705 1258929\n\n\n\npiste &lt;- st_linestring(coords)\n\npiste\n\n\nplot(piste)\n\n\n\n\n\n\n\n\n\n\nPolygons\n\ncoords_2 &lt;- c(\n  2684142, 1255702, # ‚Ü∞ \n  2685600, 1256958, # start and end must\n  2682534, 1259699, # be identical (closed)\n  2684142, 1255702  # ‚Ü≤ \n) |&gt; \n  matrix(ncol = 2, byrow = TRUE) |&gt; \n  list()\n\ncoords_2\n\n[[1]]\n        [,1]    [,2]\n[1,] 2684142 1255702\n[2,] 2685600 1256958\n[3,] 2682534 1259699\n[4,] 2684142 1255702\n\n\n\nflughafen &lt;- st_polygon(coords_2)\n\nflughafen\n\n\nplot(flughafen)",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#sfc-simple-feature-geometry-columns",
    "href": "simple-features.html#sfc-simple-feature-geometry-columns",
    "title": "Simple Features",
    "section": "sfc: Simple feature geometry columns",
    "text": "sfc: Simple feature geometry columns\n\nUsually, a sfc contains more than one sfg.\nThis is not mandatory, and for convenience we will just use a single sfg to showcase sfc\nAs you might have noticed, we didn‚Äôt specify a CRS when creating the sfg objects. This is because we weren‚Äôt able to. With sfc, we can (and should) specify a crs.\n\n\nfracht_sfc &lt;- st_sfc(fracht, crs = 2056)\n\nfracht_sfc\n\nGeometry set for 1 feature \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2685374 ymin: 1256519 xmax: 2685374 ymax: 1256519\nProjected CRS: CH1903+ / LV95\n\n\n\npiste_sfc &lt;- st_sfc(piste, crs = 2056)\n\npiste_sfc\n\nGeometry set for 1 feature \nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 2682705 ymin: 1255553 xmax: 2684336 ymax: 1258929\nProjected CRS: CH1903+ / LV95\n\n\n\nflughafen_sfc &lt;- st_sfc(flughafen, crs = 2056)\n\nflughafen_sfc\n\nGeometry set for 1 feature \nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2682534 ymin: 1255702 xmax: 2685600 ymax: 1259699\nProjected CRS: CH1903+ / LV95",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#sf-simple-features",
    "href": "simple-features.html#sf-simple-features",
    "title": "Simple Features",
    "section": "sf: Simple features",
    "text": "sf: Simple features\n\nSimple features have attributes\nIn order to add attributes to a simple feature column (sfc), we need to convert it to a simple feature (sf)\nA sf object is a subset of a data.frame. Many (all?) things which can be done with a data.frame, can be done with an sf object\nMany tidyverse functions are implemented to nicely work with sf\nNote: Geometries are sticky. This means they aren‚Äôt dropped implicitly\n\n\nfracht_sf &lt;- st_as_sf(fracht_sfc)\n\nfracht_sf$name &lt;- \"Ost\"\n\n\n# sf objects are also dataframes\nis.data.frame(fracht_sf)\n\n[1] TRUE\n\n\n\n# Geometries are sticky\nfracht_sf[, \"name\"] \n\nSimple feature collection with 1 feature and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2685374 ymin: 1256519 xmax: 2685374 ymax: 1256519\nProjected CRS: CH1903+ / LV95\n  name                       x\n1  Ost POINT (2685374 1256519)\n\n\n\npiste_sf &lt;- st_as_sf(piste_sfc)\n\npiste_sf$nr &lt;- 34\n\nflughafen_sf &lt;- st_as_sf(flughafen_sfc)\n\nflughafen_sf$name &lt;- \"Flughafen Z√ºrich\"\n\nflughafen_sf\n\nSimple feature collection with 1 feature and 1 field\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2682534 ymin: 1255702 xmax: 2685600 ymax: 1259699\nProjected CRS: CH1903+ / LV95\n                               x             name\n1 POLYGON ((2684142 1255702, ... Flughafen Z√ºrich",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#sec-plotting",
    "href": "simple-features.html#sec-plotting",
    "title": "Simple Features",
    "section": "Plotting simple features",
    "text": "Plotting simple features\n\nVarious libraries support plotting sf objects:\n\nbase R (sf provides a plot-method)\nGeneral purpose libraries such as ggplot2\nDedicated geospatial plotting libraries such as tmap\n\nUse:\n\nbase R: If you want to take a quick look at your data. Base R has the most compact syntax and is extremely fast in plotting\nggplot2: If you only have (small-ish) vector data (no raster) and/or want to leverage the power of ggplot2\ntmap: If you want to use all features a dedicated library for geospatial data has to offer: North arrow, scale bar, interactive (web) maps\n\n\nplot(st_geometry(flughafen_sf))\nplot(piste_sf, add = TRUE)\nplot(fracht_sf, add = TRUE)\nlibrary(ggplot2)\nggplot() +\n  geom_sf(data = flughafen_sf) +\n  geom_sf(data = piste_sf) +\n  geom_sf(data = fracht_sf)\nlibrary(tmap)\ntm_shape(flughafen_sf) + tm_polygons() +\n  tm_shape(piste_sf) + tm_lines() +\n  tm_shape(fracht_sf) + tm_dots()\n\n\n\n\n\n\nbase R\n\n\n\n\n\n\n\nlibrary ggplot2\n\n\n\n\n\n\n\nlibrary tmap\n\n\n\n\n\n\nThe tmap library can render the map either in a static plot as above (the default) or as an interactive web map (see below)\n\n\n# set tmap_mode to \"view\" for an interactive web map\ntmap_mode(\"view\")\n\ntm_shape(flughafen_sf) + tm_polygons() +\n  tm_shape(piste_sf) + tm_lines() +\n  tm_shape(fracht_sf) + tm_dots()",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#tasks",
    "href": "simple-features.html#tasks",
    "title": "Simple Features",
    "section": "ü™ï Tasks",
    "text": "ü™ï Tasks\n\nCreate some simple feature geometries (sfg) of objects you know ‚Äúby hand‚Äù\n\n\nCreate at least one POINT, one LINESTRING and one POLYGON geometry\nYou can capture the coordinates of the nodes from map.geo.admin if these are is Switzerland and openstreetmap (or similar) if they aren‚Äôt\n\n\nCreate simple feature columns from you sfgs. Make sure that you assign the correct CRS\nCreate simple features (sf) from your sfcs and add some attributes\n\n\n\n\n\nDorman, Michael. 2023. ‚ÄúPreface &#X2014; Spatial Data Programming with Python ‚Äî Geobgu.xyz.‚Äù https://geobgu.xyz/py/.\n\n\nPebesma, Edzer. 2018. ‚ÄúSimple Features for R: Standardized Support for Spatial Vector Data.‚Äù The R Journal 10 (1): 439‚Äì46. https://doi.org/10.32614/RJ-2018-009.",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#footnotes",
    "href": "simple-features.html#footnotes",
    "title": "Simple Features",
    "section": "",
    "text": "non-selfintersecting‚Ü©Ô∏é\nnon-selfintersecting‚Ü©Ô∏é\nthe first ring denotes the exterior ring, zero or more subsequent rings denote holes in this exterior ring‚Ü©Ô∏é",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "vector-io.html",
    "href": "vector-io.html",
    "title": "Vector data i/o",
    "section": "",
    "text": "GDAL / ogr2ogr",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data i/o</span>"
    ]
  },
  {
    "objectID": "vector-io.html#gdal-ogr2ogr",
    "href": "vector-io.html#gdal-ogr2ogr",
    "title": "Vector data i/o",
    "section": "",
    "text": "GDAL\n\nis an open source translator library for raster and vector geospatial data formats.\nstands for Geospatial Data Abstraction Library\nis used in most geospatial software, be it FOSS or proprietary. The list includes: ArcGIS, QGIS, R (sf) and Python (geopandas)",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data i/o</span>"
    ]
  },
  {
    "objectID": "vector-io.html#gdal-vector-drivers-read",
    "href": "vector-io.html#gdal-vector-drivers-read",
    "title": "Vector data i/o",
    "section": "GDAL Vector drivers (read)",
    "text": "GDAL Vector drivers (read)\n\nSince GDAL supports a long list of different geospatial file formats, these are in turn supported by {sf}\nRun the function st_drivers for a full list\n{sf} tries to guess the correct driver based on the file extension (see below)\n\n\n# sf uses the geojson driver, based on the file extension\n# (data from moodle ‚Üí  Spatial Databases II ‚Üí Database Files)\nstationen_schweiz &lt;- read_sf(\"data/uebung1/stationen_schweiz.geojson\")\n\n\n# sf uses the shapefile driver, based on the file extension\n# (data from moodle ‚Üí  Spatial Analysis I ‚Üí Exercise Data) \nhoheitsgebiet &lt;- read_sf(\"data/Spatial_Analysis_I/Hoheitsgebiet/HOHEITSGEBIET_FR.shp\")",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data i/o</span>"
    ]
  },
  {
    "objectID": "vector-io.html#multiple-layers-in-one-file",
    "href": "vector-io.html#multiple-layers-in-one-file",
    "title": "Vector data i/o",
    "section": "Multiple layers in one file",
    "text": "Multiple layers in one file\n\nSome file formats, e.g.¬†Geopackages (*.gpkg) or Geodatabases (*.gdb) support multiple datasets in a single file.\nIf no specific layer is requested read_sf() will import the first available layer\nIf more than 1 layers are available, read_sf() will return a warning\nThe function st_layers() will list all available layers\n\n\n# Note the warning:\n\ntlm3d_path &lt;- \"data/Spatial_Analysis_II/swiss_TLM3D.gpkg\"\n\ntlm3d &lt;- read_sf(tlm3d_path)\n\nWarning in CPL_read_ogr(dsn, layer, query, as.character(options), quiet, :\nautomatically selected the first layer in a data source containing more than\none.\n\n\n\n# This will list all layers, including some metadata\nst_layers(tlm3d_path)\n\nDriver: GPKG \nAvailable layers:\n    layer_name        geometry_type features fields       crs_name\n1       tlm_bb     3D Multi Polygon    49321     13 CH1903+ / LV95\n2 tlm_strassen 3D Multi Line String   191644     27 CH1903+ / LV95\n\n\n\ntlm_bb &lt;- read_sf(tlm3d_path, \"tlm_bb\")",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data i/o</span>"
    ]
  },
  {
    "objectID": "vector-io.html#sql-queries-during-import",
    "href": "vector-io.html#sql-queries-during-import",
    "title": "Vector data i/o",
    "section": "SQL queries during import",
    "text": "SQL queries during import\n\nread_sf() understands an Spatialite SQL query provided in the query = argument\nIn case query = is used, skip the layers = argument, since the layers is specified in the query\n\n\ntlm_seen &lt;- read_sf(tlm3d_path, query = \"SELECT objektart, geom FROM tlm_bb WHERE objektart = 'Stehende Gewaesser'\")",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data i/o</span>"
    ]
  },
  {
    "objectID": "vector-io.html#gdal-vector-drivers-write",
    "href": "vector-io.html#gdal-vector-drivers-write",
    "title": "Vector data i/o",
    "section": "GDAL Vector drivers (write)",
    "text": "GDAL Vector drivers (write)\n\nThe function st_write() is used to export an sf object to file\nMost vector drivers support reading and writing (see st_drivers / column write)\nMany file formats support appending to the dataset (see append =)\n\n\nst_write(tlm_seen, \"data-out/seen.geojson\")\n\nWriting layer `seen' to data source `data-out/seen.geojson' using driver `GeoJSON'\nWriting 1189 features with 1 fields and geometry type 3D Multi Polygon.",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data i/o</span>"
    ]
  },
  {
    "objectID": "vector-io.html#tasks",
    "href": "vector-io.html#tasks",
    "title": "Vector data i/o",
    "section": "ü™ï Tasks",
    "text": "ü™ï Tasks\n\nImport the datasets from Spatial Analysis I and II using R\nExplore these datasets by printing the sf objects to the console\nTry different visualization methods (see Plotting simple features)",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data i/o</span>"
    ]
  },
  {
    "objectID": "spatial-operations.html",
    "href": "spatial-operations.html",
    "title": "Spatial Vector Operation",
    "section": "",
    "text": "Thematic queries\ntlm3d_path &lt;- \"data/Spatial_Analysis_II/swiss_TLM3D.gpkg\"\n\ntlm_seen &lt;- read_sf(tlm3d_path, query = \"SELECT objektart, geom FROM tlm_bb WHERE objektart = 'Stehende Gewaesser'\")\ntlm_bb &lt;- read_sf(tlm3d_path, \"tlm_bb\")\n\n# Subsetting with base-R\ntlm_seen &lt;- tlm_bb[tlm_bb$objektart == \"Stehende Gewaesser\", ]\n\n# Subsetting using dplyr::filter\ntlm_seen &lt;- filter(tlm_bb, objektart == \"Stehende Gewaesser\")",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "spatial-operations.html#thematic-queries",
    "href": "spatial-operations.html#thematic-queries",
    "title": "Spatial Vector Operation",
    "section": "",
    "text": "SQL queries can be performed with file import\n\n\n\nHowever, datasets can also be queried after import using data.frame methods (such as subset or dplyr::filter)",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "spatial-operations.html#spatial-queries-using-binary-predicate-functions",
    "href": "spatial-operations.html#spatial-queries-using-binary-predicate-functions",
    "title": "Spatial Vector Operation",
    "section": "Spatial queries using binary predicate functions",
    "text": "Spatial queries using binary predicate functions\n\nFor example, Select all forests in the canton of Luzern\nSpatial query functions include: st_contains(), st_contains(), st_contains(), st_contains(), and many more (see here)\nThese spatial queries are called geometric binary predicates (see link above).\nThis family of functions return so called sparse matrices: a list the same length as x, which, for each element in x, contains the indices of y where the condition is met. For example:\nThey could return cross matrices, but these usually have a larger memory, since they have are \\(x \\times y\\) in size\n\n\nluzern &lt;- read_sf(\"data/Spatial_Analysis_II/swissBOUNDARIES3D.gpkg\")\n\ntlm_wald &lt;- filter(tlm_bb, objektart == \"Wald\")\n\n# The dataset already has this crs (2056), but apparently \n# does not realize this\ntlm_wald &lt;- st_set_crs(tlm_wald, 2056)\n\n\nquery_res &lt;- st_intersects(tlm_wald, luzern)\n\nquery_res\n\nSparse geometry binary predicate list of length 8096, where the\npredicate was `intersects'\nfirst 10 elements:\n 1: (empty)\n 2: (empty)\n 3: (empty)\n 4: (empty)\n 5: (empty)\n 6: (empty)\n 7: (empty)\n 8: (empty)\n 9: (empty)\n 10: (empty)\n\n\n\n(The first 10 elements are empty, because these are not within Luzern)\nThis list can be used to subset x (TRUE where the list is not empty):\n\n\nwald_luzern &lt;- tlm_wald[lengths(query_res) &gt; 0,]\n\n\nggplot(luzern) + \n  geom_sf(data = wald_luzern, fill = \"darkgreen\") +\n  geom_sf(color = \"red\", fill = NA) \n\n\n\n\n\n\n\nFigure¬†3.1: Note how some forests are outside the canton‚Äôs border. This is the nature of st_intersects. If even a small part of a forest feature is within Luzern, this feature intersects Luzern and is therefore retained. To query only forests that are completly within Luzern, use st_within().",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "spatial-operations.html#spatial-queries-using-or-st_filter",
    "href": "spatial-operations.html#spatial-queries-using-or-st_filter",
    "title": "Spatial Vector Operation",
    "section": "Spatial queries using [ or st_filter",
    "text": "Spatial queries using [ or st_filter\n\nThe code above was for illustration purposes. The code can be written more concise:\n\n\n# using sf-methods in base-R\ntlm_wald[luzern,, op = st_intersects]\n\n# using st_filter\nst_filter(tlm_wald, luzern, .predicate = st_intersects)",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "spatial-operations.html#overlay-analysis",
    "href": "spatial-operations.html#overlay-analysis",
    "title": "Spatial Vector Operation",
    "section": "Overlay Analysis",
    "text": "Overlay Analysis\n\nIn the example illustrated in Figure¬†3.1, we have the choice of subsetting forests that either intersect Luzern ever so slightly (st_intersects), or that lie completely within Luzern (st_within).\nDepending on the question, both options can be unsatisfactory (e.g.¬†if the question was Which percentage of Luzern is covered by forest?)\nFor some cases, it might be necessary to ‚Äúcut‚Äù the forest area at the cantons border\nThis can be achieved with st_intersection (which is different from intersects)\nThere are several other functions that work on pairs of geometries. See Geometric operations on pairs of simple feature geometry sets\nThere are even more functions that work on single geometries, e.g.¬†st_buffer. See Geometric unary operations on simple feature geometry sets\n\n\nlibrary(glue)\nlibrary(scales)\nwald_luzern2 &lt;- st_intersection(luzern, wald_luzern)\n\nggplot(luzern) + \n  geom_sf(fill = \"gray\", color = NA) +\n  geom_sf(data = wald_luzern2, fill = \"darkgreen\", color = NA)\n\n\n\n\n\n\n\n\n\nNow, it‚Äôs possible to compute the area of Luzern and the forest that intersects Luzern using the function st_area.\nThere are several functions to compute geometric measurements of sf-objects.\n\n\nsum(st_area(wald_luzern2))/st_area(luzern)\n\n0.2721733 [1]",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "spatial-operations.html#tasks",
    "href": "spatial-operations.html#tasks",
    "title": "Spatial Vector Operation",
    "section": "ü™ï Tasks",
    "text": "ü™ï Tasks\nFrom the exercise in Spatial Analysis I, solve the following tasks using R:\n\nTask 2: Thematic Selections (Select by Attributes)\nTask 3: Exporting Selected Features to a New Layer sf object\nTask 6: Intersect (Intersection)\nTask 8: Buffer\nTask 9: Spatial Selection (Select by Location)",
    "crumbs": [
      "Vector Data",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Dorman, Michael. 2023. ‚ÄúPreface &#X2014;\nSpatial Data Programming with\nPython ‚Äî Geobgu.xyz.‚Äù https://geobgu.xyz/py/.\n\n\nPebesma, Edzer. 2018. ‚ÄúSimple Features for R:\nStandardized Support for Spatial Vector Data.‚Äù\nThe R Journal 10 (1): 439‚Äì46. https://doi.org/10.32614/RJ-2018-009.",
    "crumbs": [
      "References"
    ]
  }
]