[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ADSL GIScience and Geodatabases",
    "section": "",
    "text": "Welcome\nWelcome to the Part Geocomputation in the Course GIScience and Geodatabases. This course is taught in the Bachelor Degree Applied Digital Life Sciences at the Zurich University of Applied Sciences (ZHAW).",
    "crumbs": [
      "Welcome"
    ]
  },
  {
    "objectID": "simple-features.html",
    "href": "simple-features.html",
    "title": "Simple Features",
    "section": "",
    "text": "Simple feature standard",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#simple-feature-standard",
    "href": "simple-features.html#simple-feature-standard",
    "title": "Simple Features",
    "section": "",
    "text": "Simple features is an open standard (ISO 19125-1:2004) developed and endorsed by the Open Geospatial Consortium (OGC)\nThe standard is widely implemented in spatial databases (such as PostGIS), desktop GIS (such as ArcGIS, QGIS), scripting languages (such as R, Python) and forms the vector data basis for libraries such as GDAL.",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#what-is-a-feature",
    "href": "simple-features.html#what-is-a-feature",
    "title": "Simple Features",
    "section": "What is a feature?",
    "text": "What is a feature?\nThe standard says:\n\nA simple feature is defined [‚Ä¶] to have both spatial and non-spatial attributes. Spatial attributes are geometry valued, and simple features are based on 2D geometry with linear interpolation between vertices.\n\n\n\nA feature is thought of as a thing / an object in the real world, such as a building or a tree.\nFeatures have:\n\na geometry describing where on Earth the feature is located\nattributes, which describe other properties.\n\n\n\n\nFor example:\n\nThe geometry of a tree can be the delineation of its crown, of its stem, or the point indicating its center\nattributes (properties) may include its height, color, diameter at breast height at a particular date, and so on",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#simple-feature-model",
    "href": "simple-features.html#simple-feature-model",
    "title": "Simple Features",
    "section": "Simple Feature Model",
    "text": "Simple Feature Model\n\nSimple features is a hierarchical data model that represents a wide range of geometry types.\nAll geometries are composed of points in a 2-, 3- or 4-dimensional space\n\n\n\nOf 18 geometry types supported by the specification, only the following seven (see Figure¬†1.1 and Table¬†1.1) are used in the vast majority of geographic research:\n\nThree basic types: points, linestrings, polygons\nThree composite types: mutlipoints, multilinestrings, multipolygons\nOne special case: geometrycollection (which can be a conglomarate of all the afore mentioned)\n\nThese seven core geometry types are fully supported by the R package sf (Pebesma 2018)\n\n\n\n\n\n\n\n\nFigure¬†1.1: Image source: Dorman (2023)\n\n\n\n\n\n\n\n\nTable¬†1.1: Source: Pebesma (2018)\n\n\n\n\n\n\n\n\n\n\n\nType\nDescription\n# of Dimension\n\n\n\n\nPOINT\nzero-dimensional geometry containing a single point\n0\n\n\nLINESTRING\nsequence of points connected by straight1 line pieces\n1\n\n\nPOLYGON\nsequence of points form a closed2 ring3\n2\n\n\nMULTIPOINT\nset of points\n0\n\n\nMULTILINESTRING\nset of linestrings\n1\n\n\nMULTIPOLYGON\nset of polygons\n2\n\n\nGEOMETRYCOLLECTION\nset of geometries of any of the above types\nNA",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#simple-features-in-r",
    "href": "simple-features.html#simple-features-in-r",
    "title": "Simple Features",
    "section": "Simple features in R",
    "text": "Simple features in R\nSimple Features in R is modelled in three levels:\n\nSimple feature geometries (sfg): Individual Simple Feature objects\nSimple Feature geometry columns (sfc): A list column of sfgs\nSimple Features (with attributes): A sfc with attributes, i.e.¬†additional columns",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#sfg-simple-feature-geometry",
    "href": "simple-features.html#sfg-simple-feature-geometry",
    "title": "Simple Features",
    "section": "sfg: simple feature geometry",
    "text": "sfg: simple feature geometry\n\nSimple feature geometries are implemented as R native data, using the following rules:\n\na single POINT is a numeric vector\na set of points, e.g.¬†in a LINESTRING or ring of a POLYGON is a matrix, each row containing a point\nany other set is a list\n\n\n\n\nPoints\n\n# creator functions are rarely used in practice, since we typically bulk  \n# read and write spatial data. They are useful for illustration)\n\nlibrary(sf)\nfracht &lt;- st_point(c(2685374, 1256519))\n\nfracht\n\n\nplot(fracht)\n\n\n\n\n\n\n\n\n\n\n\nLinestrings\n\ncoords &lt;- c(\n  2684336, 1255553, \n  2682705, 1258929\n  ) |&gt; \n  matrix(ncol = 2, byrow = TRUE)\n\ncoords\n\n        [,1]    [,2]\n[1,] 2684336 1255553\n[2,] 2682705 1258929\n\n\n\n\npiste &lt;- st_linestring(coords)\n\npiste\n\n\nplot(piste)\n\n\n\n\n\n\n\n\n\n\n\nPolygons\n\ncoords_2 &lt;- c(\n  2684142, 1255702, # ‚Ü∞ \n  2685600, 1256958, # start and end must\n  2682534, 1259699, # be identical (closed)\n  2684142, 1255702  # ‚Ü≤ \n) |&gt; \n  matrix(ncol = 2, byrow = TRUE) |&gt; \n  list()\n\ncoords_2\n\n[[1]]\n        [,1]    [,2]\n[1,] 2684142 1255702\n[2,] 2685600 1256958\n[3,] 2682534 1259699\n[4,] 2684142 1255702\n\n\n\n\nflughafen &lt;- st_polygon(coords_2)\n\nflughafen\n\n\nplot(flughafen)",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#sfc-simple-feature-geometry-columns",
    "href": "simple-features.html#sfc-simple-feature-geometry-columns",
    "title": "Simple Features",
    "section": "sfc: Simple feature geometry columns",
    "text": "sfc: Simple feature geometry columns\n\nUsually, a sfc contains more than one sfg.\nThis is not mandatory, and for convenience we will just use a single sfg to showcase sfc\nAs you might have noticed, we didn‚Äôt specify a CRS when creating the sfg objects. This is because we weren‚Äôt able to. With sfc, we can (and should) specify a crs.\n\n\n\nfracht_sfc &lt;- st_sfc(fracht, crs = 2056)\n\nfracht_sfc\n\nGeometry set for 1 feature \nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2685374 ymin: 1256519 xmax: 2685374 ymax: 1256519\nProjected CRS: CH1903+ / LV95\n\n\n\n\npiste_sfc &lt;- st_sfc(piste, crs = 2056)\n\npiste_sfc\n\nGeometry set for 1 feature \nGeometry type: LINESTRING\nDimension:     XY\nBounding box:  xmin: 2682705 ymin: 1255553 xmax: 2684336 ymax: 1258929\nProjected CRS: CH1903+ / LV95\n\n\n\n\nflughafen_sfc &lt;- st_sfc(flughafen, crs = 2056)\n\nflughafen_sfc\n\nGeometry set for 1 feature \nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 2682534 ymin: 1255702 xmax: 2685600 ymax: 1259699\nProjected CRS: CH1903+ / LV95",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#sf-simple-features",
    "href": "simple-features.html#sf-simple-features",
    "title": "Simple Features",
    "section": "sf: Simple features",
    "text": "sf: Simple features\n\nSimple features have attributes\nIn order to add attributes to a simple feature column (sfc), we need to convert it to a simple feature (sf)\n\n\nfracht_sf &lt;- st_as_sf(fracht_sfc)\n\nfracht_sf$name &lt;- \"Ost\"\n\n\n\nA sf object is a subset of a data.frame. Many (all?) things which can be done with a data.frame, can be done with an sf object\nMany tidyverse functions are implemented to nicely work with sf\n\n\n# sf objects are also dataframes\nis.data.frame(fracht_sf)\n\n[1] TRUE\n\n\n\n\nGeometries are sticky. This means they aren‚Äôt dropped implicitly\n\n\n# Geometries are sticky\nfracht_sf[, \"name\"] \n\nSimple feature collection with 1 feature and 1 field\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 2685374 ymin: 1256519 xmax: 2685374 ymax: 1256519\nProjected CRS: CH1903+ / LV95\n  name                       x\n1  Ost POINT (2685374 1256519)\n\n\n\n\npiste_sf &lt;- st_as_sf(piste_sfc)\n\npiste_sf$nr &lt;- 34\n\nflughafen_sf &lt;- st_as_sf(flughafen_sfc)\n\nflughafen_sf$name &lt;- \"Flughafen Z√ºrich\"",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#sec-plotting",
    "href": "simple-features.html#sec-plotting",
    "title": "Simple Features",
    "section": "Plotting simple features",
    "text": "Plotting simple features\n\nVarious libraries support plotting sf objects:\n\nbase R (sf provides a plot-method)\nGeneral purpose libraries such as ggplot2\nDedicated geospatial plotting libraries such as tmap\n\n\n\n\nUse:\n\nbase R: If you want to take a quick look at your data. Base R has the most compact syntax and is extremely fast in plotting\nggplot2: If you only have (small-ish) vector data (no raster) and/or want to leverage the power of ggplot2\ntmap: If you want to use all features a dedicated library for geospatial data has to offer: North arrow, scale bar, interactive (web) maps\n\n\n\n# Using base R\nplot(st_geometry(flughafen_sf))\nplot(piste_sf, add = TRUE)\nplot(fracht_sf, add = TRUE)\n##########################################################\n# Using ggplot2\nlibrary(ggplot2)\nggplot() +\n  geom_sf(data = flughafen_sf) +\n  geom_sf(data = piste_sf) +\n  geom_sf(data = fracht_sf)\n##########################################################\n# Using tmap\nlibrary(tmap)\ntm_shape(flughafen_sf) + tm_polygons() +\n  tm_shape(piste_sf) + tm_lines() +\n  tm_shape(fracht_sf) + tm_dots()\n\n\n\n\n\n\n\n\n\nFigure¬†1.2: base R\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†1.3: library ggplot2\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†1.4: library tmap\n\n\n\n\n\n\n\n\nThe tmap library can render the map either in a static plot shown before or as an interactive web map (see below)\n\n\n# set tmap_mode to \"view\" for an interactive web map\ntmap_mode(\"view\")\n\ntm_shape(flughafen_sf) + tm_polygons() +\n  tm_shape(piste_sf) + tm_lines() +\n  tm_shape(fracht_sf) + tm_dots()",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#tasks",
    "href": "simple-features.html#tasks",
    "title": "Simple Features",
    "section": "ü™ï Tasks",
    "text": "ü™ï Tasks\n\nCreate some simple feature geometries (sfg) of objects you know ‚Äúby hand‚Äù. Create at least one POINT, one LINESTRING and one POLYGON geometry. You can capture the coordinates of the nodes from map.geo.admin.ch if these are is Switzerland and openstreetmap.org (or similar) if they aren‚Äôt\nCreate simple feature columns from you sfgs. Make sure that you assign the correct CRS\nCreate simple features (sf) from your sfcs and add some attributes",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#refs",
    "href": "simple-features.html#refs",
    "title": "Simple Features",
    "section": "References",
    "text": "References\n\n\n\n\nDorman, Michael. 2023. ‚ÄúSpatial Data Programming with Python ‚Äî Geobgu.xyz.‚Äù https://geobgu.xyz/py/.\n\n\nPebesma, Edzer. 2018. ‚ÄúSimple Features for R: Standardized Support for Spatial Vector Data.‚Äù The R Journal 10 (1): 439‚Äì46. https://doi.org/10.32614/RJ-2018-009.",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "simple-features.html#footnotes",
    "href": "simple-features.html#footnotes",
    "title": "Simple Features",
    "section": "",
    "text": "non-selfintersecting‚Ü©Ô∏é\nnon-selfintersecting‚Ü©Ô∏é\nthe first ring denotes the exterior ring, zero or more subsequent rings denote holes in this exterior ring‚Ü©Ô∏é",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>1</span>¬† <span class='chapter-title'>Simple Features</span>"
    ]
  },
  {
    "objectID": "vector-io.html",
    "href": "vector-io.html",
    "title": "Vector data I/O",
    "section": "",
    "text": "GDAL / ogr2ogr\nGDAL:",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "vector-io.html#sec-gdal-ogr2ogr",
    "href": "vector-io.html#sec-gdal-ogr2ogr",
    "title": "Vector data I/O",
    "section": "",
    "text": "is an open source translator library for raster and vector geospatial data formats.\nstands for Geospatial Data Abstraction Library\nis used in most geospatial software, be it FOSS or proprietary. The list includes: ArcGIS, QGIS, R (sf) and Python (geopandas)",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "vector-io.html#gdal-vector-drivers-read",
    "href": "vector-io.html#gdal-vector-drivers-read",
    "title": "Vector data I/O",
    "section": "GDAL Vector drivers (read)",
    "text": "GDAL Vector drivers (read)\n\nSince GDAL supports a long list of different geospatial file formats, most (all?) are in turn supported by {sf}\nRun the function st_drivers for a full list\n{sf} tries to guess the correct driver based on the file extension (see below)\n\n\n# sf uses the geojson driver, based on the file extension\n# (data from moodle ‚Üí  Spatial Databases II ‚Üí Database Files)\nstationen_schweiz &lt;- read_sf(\"data/uebung1/stationen_schweiz.geojson\")\n\n\n\n# sf uses the shapefile driver, based on the file extension\n# (data from moodle ‚Üí  Spatial Analysis I ‚Üí Exercise Data) \nhoheitsgebiet &lt;- read_sf(\"data/Spatial_Analysis_I/Hoheitsgebiet/HOHEITSGEBIET_FR.shp\")",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "vector-io.html#multiple-layers-in-one-file",
    "href": "vector-io.html#multiple-layers-in-one-file",
    "title": "Vector data I/O",
    "section": "Multiple layers in one file",
    "text": "Multiple layers in one file\n\nSome file formats, e.g.¬†Geopackages (*.gpkg) or Geodatabases (*.gdb) support multiple datasets in a single file.\nIf no specific layer is requested read_sf() will import the first available layer\nIf more than 1 layers are available, read_sf() will return a warning\nThe function st_layers() will list all available layers\n\n\n\ntlm3d_path &lt;- \"data/Spatial_Analysis_II/swiss_TLM3D.gpkg\"\n\n# Note the warning:\ntlm3d &lt;- read_sf(tlm3d_path)\n\nWarning in CPL_read_ogr(dsn, layer, query, as.character(options), quiet, :\nautomatically selected the first layer in a data source containing more than\none.\n\n\n\n\n# This will list all layers, including some metadata\nst_layers(tlm3d_path)\n\nDriver: GPKG \nAvailable layers:\n    layer_name        geometry_type features fields       crs_name\n1       tlm_bb     3D Multi Polygon    49321     13 CH1903+ / LV95\n2 tlm_strassen 3D Multi Line String   191644     27 CH1903+ / LV95\n\n\n\n\n# To import a single layer\ntlm_bb &lt;- read_sf(tlm3d_path, \"tlm_bb\")",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "vector-io.html#sql-queries-during-import",
    "href": "vector-io.html#sql-queries-during-import",
    "title": "Vector data I/O",
    "section": "SQL queries during import",
    "text": "SQL queries during import\n\nread_sf() can parse a (spatialite) SQL query provided in the query = argument\nIn case query = is used, the layers = argument should be skipped (since the layers is specified in the query)\n\n\ntlm_seen &lt;- read_sf(\n  tlm3d_path, \n  query = \"SELECT objektart, geom FROM tlm_bb WHERE objektart = 'Stehende Gewaesser'\"\n  )",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "vector-io.html#gdal-vector-drivers-write",
    "href": "vector-io.html#gdal-vector-drivers-write",
    "title": "Vector data I/O",
    "section": "GDAL Vector drivers (write)",
    "text": "GDAL Vector drivers (write)\n\nThe function st_write() is used to export an sf object to file\nMost vector drivers support reading and writing (see st_drivers / column write)\nMany file formats support appending to the dataset (see append =)\n\n\nst_write(tlm_seen, \"data-out/seen.geojson\")",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "vector-io.html#tasks",
    "href": "vector-io.html#tasks",
    "title": "Vector data I/O",
    "section": "ü™ï Tasks",
    "text": "ü™ï Tasks\n\nImport the datasets from Spatial Analysis I and II using R\nExplore these datasets by printing the sf objects to the console\nTry different visualization methods (see Plotting simple features)",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>2</span>¬† <span class='chapter-title'>Vector data I/O</span>"
    ]
  },
  {
    "objectID": "spatial-operations.html",
    "href": "spatial-operations.html",
    "title": "Spatial Vector Operation",
    "section": "",
    "text": "Thematic queries\ntlm3d_path &lt;- \"data/Spatial_Analysis_II/swiss_TLM3D.gpkg\"\n\ntlm_seen &lt;- read_sf(\n  tlm3d_path, \n  query = \"SELECT objektart, geom FROM tlm_bb WHERE objektart = 'Stehende Gewaesser'\"\n  )\ntlm_bb &lt;- read_sf(tlm3d_path, \"tlm_bb\")\n\n# Subsetting with base-R\ntlm_seen &lt;- tlm_bb[tlm_bb$objektart == \"Stehende Gewaesser\", ]\n\n# Subsetting using dplyr::filter\ntlm_seen &lt;- filter(tlm_bb, objektart == \"Stehende Gewaesser\")",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "spatial-operations.html#thematic-queries",
    "href": "spatial-operations.html#thematic-queries",
    "title": "Spatial Vector Operation",
    "section": "",
    "text": "SQL queries can be performed with file import\n\n\n\n\nHowever, datasets can also be queried after import using data.frame methods (such as [ or dplyr::filter)",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "spatial-operations.html#spatial-queries-using-binary-predicate-functions",
    "href": "spatial-operations.html#spatial-queries-using-binary-predicate-functions",
    "title": "Spatial Vector Operation",
    "section": "Spatial queries using binary predicate functions",
    "text": "Spatial queries using binary predicate functions\nTake the following example:\n\nSelect all forests in the canton of Luzern\n\n\nSpatial query functions include: st_intersects(), st_touches(), st_contains(), st_overlaps(), and many more\nThese spatial queries are called geometric binary predicates\n\n\n\nThis family of functions return so called sparse matrices: a list the same length as x, which, for each element in x, contains the indices of y where the condition is met. For example:\nThey could return cross matrices, but these usually have a larger memory, since they have are \\(x \\times y\\) in size\n\n\n\nluzern &lt;- read_sf(\"data/Spatial_Analysis_II/swissBOUNDARIES3D.gpkg\")\n\ntlm_wald &lt;- filter(tlm_bb, objektart == \"Wald\")\n\n# The dataset already has this crs (2056), but apparently \n# does not realize this\ntlm_wald &lt;- st_set_crs(tlm_wald, 2056)\n\n\nquery_res &lt;- st_intersects(tlm_wald, luzern)\n\n\n\n# Note the length of the output equals nrow(tlm_wald)\nquery_res\n\nSparse geometry binary predicate list of length 8096, where the\npredicate was `intersects'\nfirst 10 elements:\n 1: (empty)\n 2: (empty)\n 3: (empty)\n 4: (empty)\n 5: (empty)\n 6: (empty)\n 7: (empty)\n 8: (empty)\n 9: (empty)\n 10: (empty)\n\n\n\n(The first 10 elements are empty, because these are not within Luzern)\nThis list can be used to subset x (TRUE where the list is not empty):\n\n\n\n# Note the use of lenghts (with an s) to get the length of each element in the \n# list\nwald_luzern &lt;- tlm_wald[lengths(query_res) &gt; 0,]\n\n\n\n\n\n\n\n\n\n\nFigure¬†3.1: Note how some forests are outside the canton‚Äôs border. This is the nature of st_intersects. If even a small part of a forest feature is within Luzern, this feature intersects Luzern and is therefore retained. To query only forests that are completly within Luzern, use st_within().",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "spatial-operations.html#spatial-queries-using-or-st_filter",
    "href": "spatial-operations.html#spatial-queries-using-or-st_filter",
    "title": "Spatial Vector Operation",
    "section": "Spatial queries using [ or st_filter",
    "text": "Spatial queries using [ or st_filter\n\nThe code above was for illustration purposes. The code can be written more concise:\n\n\n# using sf-methods in base-R\ntlm_wald[luzern,, op = st_intersects]\n\n# using st_filter\nst_filter(tlm_wald, luzern, .predicate = st_intersects)\n\n\nThe default value for op and .predicate is st_intersects, so these arguments could also have been omitted",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "spatial-operations.html#overlay-analysis",
    "href": "spatial-operations.html#overlay-analysis",
    "title": "Spatial Vector Operation",
    "section": "Overlay Analysis",
    "text": "Overlay Analysis\n\nIn the example illustrated in Figure¬†3.1, we have the choice of subsetting forests that either intersect Luzern ever so slightly (st_intersects), or that lie completely within Luzern (st_within).\nDepending on the question, both options can be unsatisfactory (e.g.¬†if the question was Which percentage of Luzern is covered by forest?)\nFor some cases, it might be necessary to ‚Äúcut‚Äù the forest area at the cantons border\n\n\n\nThis can be achieved with st_intersection (which is different from intersects)\nThere are several other functions that work on pairs of geometries. See Geometric operations on pairs of simple feature geometry sets\nThere are even more functions that work on single geometries, e.g.¬†st_buffer. See Geometric unary operations on simple feature geometry sets\n\n\n\nwald_luzern2 &lt;- st_intersection(luzern, wald_luzern)\n\n\n\n\n\n\n\n\n\n\n\n\nNow, it‚Äôs possible to compute the area of Luzern and the forest that intersects Luzern using the function st_area.\nThere are several functions to compute geometric measurements of sf-objects.\n\n\nsum(st_area(wald_luzern2))/st_area(luzern)\n\n0.2721733 [1]",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "spatial-operations.html#tasks",
    "href": "spatial-operations.html#tasks",
    "title": "Spatial Vector Operation",
    "section": "ü™ï Tasks",
    "text": "ü™ï Tasks\nFrom the exercise in Spatial Analysis I, solve the following tasks using R:\n\nTask 2: Thematic Selections (Select by Attributes)\nTask 3: Exporting Selected Features to a New Layer sf object\nTask 6: Intersect (Intersection)\nTask 8: Buffer\nTask 9: Spatial Selection (Select by Location)",
    "crumbs": [
      "Vector Data Lecture",
      "<span class='chapter-number'>3</span>¬† <span class='chapter-title'>Spatial Vector Operation</span>"
    ]
  },
  {
    "objectID": "vector-data-exercise.html",
    "href": "vector-data-exercise.html",
    "title": "Vector Data Exercise",
    "section": "",
    "text": "Introduction\nIn this exercise, you will apply spatial vector operations to answer real-world planning and environmental questions. You have access to topographic data from Swiss TLM3D and administrative boundaries. Your task is to use appropriate spatial analysis methods to answer the questions described in the task.\nChoose at least 2 Tasks (‚ÄúSzenarios‚Äù) and solve these!\nAll data is available on moodle, under the section Spatial Analysis I:\nAll data use CRS EPSG:2056 (CH1903+ / LV95).",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Vector Data Exercise</span>"
    ]
  },
  {
    "objectID": "vector-data-exercise.html#introduction",
    "href": "vector-data-exercise.html#introduction",
    "title": "Vector Data Exercise",
    "section": "",
    "text": "swiss_TLM3D.gpkg contains:\n\ntlm_bb: Land cover polygons with attribute objektart (Wald, Stehende Gewaesser, Feuchtgebiet, Fels, Lockergestein, Gletscher, etc.)\ntlm_strassen: Road network with attribute objektart (Autobahn, Autostrasse, various street widths, paths, etc.)\n\nswissBOUNDARIES3D.gpkg contains:\n\nkantonsgebiet_lu: Canton of Luzern boundary",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Vector Data Exercise</span>"
    ]
  },
  {
    "objectID": "vector-data-exercise.html#scenario-1-protected-area-planning",
    "href": "vector-data-exercise.html#scenario-1-protected-area-planning",
    "title": "Vector Data Exercise",
    "section": "Scenario 1: Protected Area Planning",
    "text": "Scenario 1: Protected Area Planning\nThe canton is considering establishing a nature protection zone for wetland ecosystems. To inform this decision, you need to analyze the current state of wetlands.\n\nQuestion 1.1: How much wetland area (‚ÄúFeuchtgebiet‚Äù) currently exists in the canton of Luzern (in km¬≤)?\nQuestion 1.2: Wetlands are ecologically most valuable when they are connected to water bodies. Identify all wetlands that are either directly adjacent to or within 50 meters of standing water bodies (‚ÄúStehende Gewaesser‚Äù). What percentage of the total wetland area does this represent?\nQuestion 1.3: Create a map showing:\n\nAll wetlands in the canton\nWetlands connected to water (highlighted differently)\nStanding water bodies\n\n\nThink about: Which spatial operations do you need? How do you define ‚Äúconnected‚Äù?",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Vector Data Exercise</span>"
    ]
  },
  {
    "objectID": "vector-data-exercise.html#scenario-2-accessibility-analysis",
    "href": "vector-data-exercise.html#scenario-2-accessibility-analysis",
    "title": "Vector Data Exercise",
    "section": "Scenario 2: Accessibility Analysis",
    "text": "Scenario 2: Accessibility Analysis\nA hiking organization wants to understand forest accessibility in Luzern.\n\nQuestion 2.1: Calculate the total forest area in Luzern that is accessible by small paths (1m or 2m wide paths: ‚Äú1m Weg‚Äù, ‚Äú2m Weg‚Äù). Define ‚Äúaccessible‚Äù as being within 200 meters of such a path.\nQuestion 2.2: What percentage of Luzern‚Äôs total forest area is accessible by these small paths?\nQuestion 2.3: Compare this with accessibility by major roads (Autobahn, Autostrasse, and streets ‚â•6m). How much forest area is within 200m of major roads?\nQuestion 2.4: Create a visualization that effectively communicates your findings.\n\nThink about: How do you combine multiple road types? How do you avoid double-counting areas accessible by multiple paths?",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Vector Data Exercise</span>"
    ]
  },
  {
    "objectID": "vector-data-exercise.html#scenario-3-alpine-environment-analysis",
    "href": "vector-data-exercise.html#scenario-3-alpine-environment-analysis",
    "title": "Vector Data Exercise",
    "section": "Scenario 3: Alpine Environment Analysis",
    "text": "Scenario 3: Alpine Environment Analysis\nClimate researchers are interested in high-altitude features in Luzern.\n\nQuestion 3.1: Identify all rocky areas in Luzern by combining the following land cover types: ‚ÄúFels‚Äù, ‚ÄúFels locker‚Äù, ‚ÄúFelsbloecke‚Äù, ‚ÄúFelsbloecke locker‚Äù, and ‚ÄúLockergestein‚Äù. What is their total area?\nQuestion 3.2: Some of these rocky areas may contain glaciers or permanent snow. Find all rocky areas that are within 100 meters of glaciers (‚ÄúGletscher‚Äù) or snow fields (‚ÄúSchneefeld Toteis‚Äù). How much area does this represent?\nQuestion 3.3: Create a map showing the spatial distribution of:\n\nAll rocky areas\nRocky areas near ice/snow\nGlaciers and snow fields\n\n\nThink about: Are glaciers and snow fields already part of rocky areas, or separate? How does this affect your analysis?",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Vector Data Exercise</span>"
    ]
  },
  {
    "objectID": "vector-data-exercise.html#scenario-4-integrated-analysis",
    "href": "vector-data-exercise.html#scenario-4-integrated-analysis",
    "title": "Vector Data Exercise",
    "section": "Scenario 4: Integrated Analysis",
    "text": "Scenario 4: Integrated Analysis\nResearch Question: The canton wants to identify potential locations for small reservoirs for agricultural water supply. Suitable locations should meet ALL of the following criteria:\n\nLocated in or near wetlands (within 20m)\nWithin 300m of an existing road (any type, for construction access)\nNOT in protected forest areas\nNOT on steep rocky terrain (Fels, Felsbloecke)\n\nTask: Identify and map all suitable areas. Report the total area available and discuss the spatial distribution of suitable locations.\nThink about: This requires combining multiple spatial operations. What is the logical sequence? Do you need union, intersection, or difference operations?",
    "crumbs": [
      "<span class='chapter-number'>4</span>¬† <span class='chapter-title'>Vector Data Exercise</span>"
    ]
  },
  {
    "objectID": "raster-data.html",
    "href": "raster-data.html",
    "title": "Raster Data",
    "section": "",
    "text": "Types of raster data",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Raster Data</span>"
    ]
  },
  {
    "objectID": "raster-data.html#types-of-raster-data",
    "href": "raster-data.html#types-of-raster-data",
    "title": "Raster Data",
    "section": "",
    "text": "Raster datasets usually represent continuous phenomena such as elevation, temperature, population density or spectral data.\nDiscrete features such as soil or land-cover classes can also be represented in the raster data model",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Raster Data</span>"
    ]
  },
  {
    "objectID": "raster-data.html#a-simple-example-elevation",
    "href": "raster-data.html#a-simple-example-elevation",
    "title": "Raster Data",
    "section": "A simple example: Elevation",
    "text": "A simple example: Elevation\n\n\n\n\n\n\n\n\n\n\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]\n [1,]  275  282  373  342  357  326  372  318  400   243   303\n [2,]  230  318  316  351  345  346  359  331  395   225   288\n [3,]  164  337  258  342  363  350  349  320  395   280   321\n [4,]  168  337  261  354  358  364  339  377  368   309   284\n [5,]  202  322  250  380  362  373  327  393  360   379   326\n [6,]   NA  310  270  361  370  363  368  368  385   383   297\n [7,]   NA  277  310  291  375  365  375  355  343   407   220\n [8,]   NA  181  325  264  381  373  389  341  305   395   252\n [9,]   NA   NA  313  264  370  384  392  328  357   376   289\n[10,]   NA   NA  298  285  370  380  386  354  349   385   311\n[11,]  402   NA  333  293  356  382  376  391  329   352   361",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Raster Data</span>"
    ]
  },
  {
    "objectID": "raster-data.html#a-more-complex-example-rbg-image",
    "href": "raster-data.html#a-more-complex-example-rbg-image",
    "title": "Raster Data",
    "section": "A more complex example: RBG Image",
    "text": "A more complex example: RBG Image\n\nA lot of raster data is obtained using remote sensing (RS)\nTypically, RS imagery consists of more than 1 band\nIn this case, the data is stored in a 3 dimensional array (where band is the 3rd-dimension)\nA RS image can contain any number of bands.\nThe most well known type of RS imagery consists of 3 Bands in the red, blue and green spectrum\n\n\n\n\n\n\n\n\n\n\nFigure¬†5.4: The bands stored internally\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†5.5: The RGB Composite",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Raster Data</span>"
    ]
  },
  {
    "objectID": "raster-data.html#each-band-is-a-2d-matrix",
    "href": "raster-data.html#each-band-is-a-2d-matrix",
    "title": "Raster Data",
    "section": "Each band is a 2D matrix",
    "text": "Each band is a 2D matrix\n\n\n\n\n\n\n\n\n\nFigure¬†5.6: Band values\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†5.7: RGB True Color Image",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Raster Data</span>"
    ]
  },
  {
    "objectID": "raster-data.html#multispectral-datasets",
    "href": "raster-data.html#multispectral-datasets",
    "title": "Raster Data",
    "section": "Multispectral Datasets",
    "text": "Multispectral Datasets\n\nMultiband datasets usually capture different parts of the EM spectrum\nE.g. the Landsat image from the previous example has 6 bands capturing the following wavelengths:\n\nBand 1: Blue (0.45 - 0.52 ¬µm)\nBand 2: Green (0.52 - 0.60 ¬µm)\nBand 3: Red (0.63 - 0.69 ¬µm)\nBand 4: Near-Infrared (0.77 - 0.90 ¬µm)\nBand 5: Short-wave Infrared (1.55 - 1.75 ¬µm)\nBand 7: Mid-Infrared (2.08 - 2.35 ¬µm)",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Raster Data</span>"
    ]
  },
  {
    "objectID": "raster-data.html#nirgb-image",
    "href": "raster-data.html#nirgb-image",
    "title": "Raster Data",
    "section": "NirGB Image",
    "text": "NirGB Image\n\n\n\n\n\n\n\n\n\nFigure¬†5.8: Band values\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†5.9: NIR-GB False Color Image",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Raster Data</span>"
    ]
  },
  {
    "objectID": "raster-data.html#representations-of-multispectral-data",
    "href": "raster-data.html#representations-of-multispectral-data",
    "title": "Raster Data",
    "section": "Representations of multispectral data",
    "text": "Representations of multispectral data\n\nA true color image is created by using the Red (3), Green (2) and Blue (1) Band and mapping these to RGB\nA false color image is created by mapping other bands to RGB\n\n\n\n\n\n\n\n\n\n\nFigure¬†5.10: The R, G and B bands mapped to RGB\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†5.11: NIR, G and B bands mapped to RGB\n\n\n\n\n\n\n\n\n\n\nPebesma, Edzer, and Roger Bivand. 2023. Spatial Data Science: With Applications in R. Boca Raton: Chapman; Hall/CRC. https://doi.org/10.1201/9780429459016.",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>5</span>¬† <span class='chapter-title'>Raster Data</span>"
    ]
  },
  {
    "objectID": "raster-io.html",
    "href": "raster-io.html",
    "title": "Raster Data I/O",
    "section": "",
    "text": "Import a raster file\nlibrary(terra)\n\ndhm25 &lt;- rast(\"data/Spatial_Analysis_II/dhm25_lu.tif\")\ndhm25\n\nclass       : SpatRaster \nsize        : 2321, 2161, 1  (nrow, ncol, nlyr)\nresolution  : 25, 25  (x, y)\nextent      : 2628987, 2683012, 1179988, 1238013  (xmin, xmax, ymin, ymax)\ncoord. ref. : CH1903+ / LV95 (EPSG:2056) \nsource      : dhm25_lu.tif \nname        : dhm25_lu \nmin value   :    381.1 \nmax value   :   3228.3",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Raster Data I/O</span>"
    ]
  },
  {
    "objectID": "raster-io.html#import-a-raster-file",
    "href": "raster-io.html#import-a-raster-file",
    "title": "Raster Data I/O",
    "section": "",
    "text": "terra uses the function rast() to import raster data\nPrinting the object will give you some basic information about the raster\n\nThe number of rows and columns, as well as the number of layers\nThe resolution of the raster, meter per pixel (25 in our case)\nThe extent of the raster, in the coordinate reference system of the raster\nThe coordinate reference system (CRS) of the raster\nThe source (in memory, or a file path)\nThe name(s) of the band(s) (we only have one band in our case)\nThe min and max values of the raster",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Raster Data I/O</span>"
    ]
  },
  {
    "objectID": "raster-io.html#geotiff",
    "href": "raster-io.html#geotiff",
    "title": "Raster Data I/O",
    "section": "GeoTIFF",
    "text": "GeoTIFF\n\nGeoTIFF is the most common raster format\nGeoTIFF is an extension to the TIFF format, which includes additional metadata to establish the spatial reference of the file\nThis includes the CRS, the extent, the resolution, and the origin of the raster\nThe metadata is either stored in the header of the file, or in an accompanying file with the same name, but different extension (.tfw or .aux.xml)\nOther important raster file formats include:\n\nCloud optimized GeoTIFF (COG): A GeoTIFF file that is optimized for cloud storage which allows for efficient, partial reading of the file over HTTP\nJPG2000 (.jp2) is a compressed raster format that is often used for satellite imagery\nNetCDF (.nc) is a format that is often used for climate data\nHDF5 (.h5) is a format that is often used for remote sensing data",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Raster Data I/O</span>"
    ]
  },
  {
    "objectID": "raster-io.html#writing-a-raster-file",
    "href": "raster-io.html#writing-a-raster-file",
    "title": "Raster Data I/O",
    "section": "Writing a raster file",
    "text": "Writing a raster file\n\nYou can write a raster object to a file using the writeRaster() function\n\n\nwriteRaster(dhm25, \"data-out/dhm25_lu.tif\", overwrite = TRUE)",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Raster Data I/O</span>"
    ]
  },
  {
    "objectID": "raster-io.html#tasks",
    "href": "raster-io.html#tasks",
    "title": "Raster Data I/O",
    "section": "ü™ï Tasks",
    "text": "ü™ï Tasks\n\nImport the raster dhm25_lu.tif from the lesson Spatial Analysis II\nVisualize the raster using the plot() function as well as the library {tmap}.",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>6</span>¬† <span class='chapter-title'>Raster Data I/O</span>"
    ]
  },
  {
    "objectID": "raster-operations.html",
    "href": "raster-operations.html",
    "title": "Raster Operations",
    "section": "",
    "text": "Introduction",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "raster-operations.html#introduction",
    "href": "raster-operations.html#introduction",
    "title": "Raster Operations",
    "section": "",
    "text": "Map algebra can be defined as operations that modify or summarize raster cell values, with reference to surrounding cells, zones, or statistical functions that apply to every cell.\nMap algebra divides raster operations into four subclasses:\n\nLocal or per-cell operations\nFocal or neighborhood operations. Most often the output cell value is the result of a 3 x 3 input cell block\nZonal operations are similar to focal operations, but the surrounding pixel grid on which new values are computed can have irregular sizes and shapes\nGlobal or per-raster operations. That means the output cell derives its value potentially from one or several entire rasters",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "raster-operations.html#global-operation-1",
    "href": "raster-operations.html#global-operation-1",
    "title": "Raster Operations",
    "section": "Global Operation (1)",
    "text": "Global Operation (1)\n\nThe most common global operations are descriptive statistics for the entire raster dataset such as the minimum, maximum or mean value.\nFor example: What is the mean elevation value for Luxembourg?\n\n\n\n\n\n\n\n\n\nFigure¬†7.1: Elevation of Luxembourg\n\n\n\n\n\n\n# note: mean(r) does not work, since \"mean\" is used as a local operator\nmean_elev &lt;- global(r, mean, na.rm = TRUE)\n\nmean_elev\n\n              mean\nelevation 347.6488",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "raster-operations.html#sec-global-2",
    "href": "raster-operations.html#sec-global-2",
    "title": "Raster Operations",
    "section": "Global Operation (2)",
    "text": "Global Operation (2)\n\nAnother type of ‚Äúglobal‚Äù operation is distance\nThis function calculates the distance from each cell to a specific target cell\nFor example, what is the distance from each cell to Luxembourg City, the capital of Luxembourg?\n\n\n\n\n\n\n\n\n\n\n\nr_dist &lt;- distance(r, luxembourg_city)\nr_dist &lt;- mask(r_dist, r)",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "raster-operations.html#sec-zonal-1",
    "href": "raster-operations.html#sec-zonal-1",
    "title": "Raster Operations",
    "section": "Zonal",
    "text": "Zonal\n\nZonal operations apply an aggregation function to multiple raster cells\nA second raster with categorical values define the ‚Äúzones‚Äù\n\nWhat is the mean altitude per municipality?\n\nmean_vals &lt;- zonal(r, zones, fun = mean, na.rm = TRUE)\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.2: The original Zones (E.g. municipalities of Luxembourg)\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.3: Mean elevation per zone / per municipality\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\n\nThe global operation can be seen as a special case of a zonal operation, where the only ‚ÄúZone‚Äù is the entire dataset",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "raster-operations.html#local-1",
    "href": "raster-operations.html#local-1",
    "title": "Raster Operations",
    "section": "Local (1)",
    "text": "Local (1)\n\nLocal operations comprise all cell-by-cell operations in one or several layers.\nFor example, we can classify the elevation into values above and below a certain threshold\n\n\n# first, create a boolean copy of the raster\nr_bool &lt;- as.logical(r)\n\nmean_elev &lt;- as.numeric(mean_elev)\nmean_elev\n\n[1] 347.6488\n\nr_bool[r &gt; mean_elev] &lt;- FALSE\nr_bool[r &lt;= mean_elev] &lt;- TRUE",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "raster-operations.html#local-2",
    "href": "raster-operations.html#local-2",
    "title": "Raster Operations",
    "section": "Local (2)",
    "text": "Local (2)\n\nThis type of (re-) classification is a very common operation\nFor more than 2 categories, we can use classify\n\n\ncuts &lt;- global(r, quantile, probs = c(0, .33, .66, 1), na.rm = TRUE)\n\nr_classify &lt;- classify(r, as.numeric(cuts))\n\n# this next line just replaces the default labels with some custom ones\nlevels(r_classify) &lt;- data.frame(ID = 0:2, category = c(\"low\",\"mid\",\"high\"))\n\np + tm_shape(r_classify) +\n    tm_raster(style = \"cat\",legend.show = TRUE, palette = \"viridis\", title = \"Elevation\") +\n    tm_layout(legend.show = TRUE)",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "raster-operations.html#local-3",
    "href": "raster-operations.html#local-3",
    "title": "Raster Operations",
    "section": "Local (3)",
    "text": "Local (3)\n\nLocal operations are often used with multiple bands\nFor example, we could calculate the mean intensity values of red, green and blue:\n\n\nl7 &lt;- rast(system.file(\"tif/L7_ETMs.tif\",package = \"stars\"))\n\nnames(l7) &lt;- c(\"B\", \"G\", \"R\", \"NIR\", \"SWIR\", \"MIR\")\n\nl7_rgb &lt;- l7[[c(\"R\",\"G\", \"B\")]]\n\nplot(l7_rgb, nr = 1)\n\n\n\n\n\n\n\n\n\nl7_rgb_mean &lt;- mean(l7_rgb)\n\nplot(l7_rgb_mean)",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "raster-operations.html#local-4",
    "href": "raster-operations.html#local-4",
    "title": "Raster Operations",
    "section": "Local (4)",
    "text": "Local (4)\n\nIn a more complex usecase, we could use the R, G and B band to calculate a grayscale value (\\(L^*\\)) using the following formula (from here):\n\n\\[\\begin{aligned}\n\nL^* &= 116 \\times Y ^ {\\frac{1}{3}} - 16\\\\\n\nY &= 0.2126 \\times R^\\gamma+0.7152 \\times G^\\gamma+0.0722 \\times B^\\gamma \\\\\n\n\n\\gamma &= 2.2\n\n\\end{aligned}\\]\n\ng &lt;- 2.2\n\nl7 &lt;- l7/255 # scale values to 0-1 (probabbly not necessary)\n\nY &lt;- 0.2126 * l7[[\"R\"]]^g + 0.7152 * l7[[\"G\"]]^g + 0.0722 * l7[[\"B\"]]^g\n\nL &lt;- 116* Y^(1/3)-16\n\n# Plot the result",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "raster-operations.html#sec-focal-1",
    "href": "raster-operations.html#sec-focal-1",
    "title": "Raster Operations",
    "section": "Focal",
    "text": "Focal\n\nWhile local functions operate on one cell focal operations take into account a central (focal) cell and its neighbors.\nThe neighborhood (also named kernel, filter or moving window) under consideration is typically of size 3-by-3 cells (that is the central cell and its eight surrounding neighbors), but can take on any other size or shape as defined by the user.\nA focal operation applies an aggregation function to all cells within the specified neighborhood, uses the corresponding output as the new value for the central cell, and moves on to the next central cell\n\n\n\n\n\n\n\nFigure¬†7.4: Note how, depending on the size of your moving window, NA‚Äôs are produced. Source: Lovelace, Nowosad, and Muenchow (2019)\n\n\n\n\nfocal3by3 &lt;- matrix(rep(1,9), ncol = 3)\n\n\nfocal11by11 &lt;- matrix(rep(1,121), ncol = 11)\n\n\nr_foc3 &lt;- focal(r, focal3by3, fun = mean, fillNA = TRUE)\n\nr_foc11 &lt;- focal(r, focal11by11, fun = mean, fillNA = TRUE)\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.5: Original values\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.6: Result of a 3x3 Focal Window\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.7: Result of a 11x11 Focal Window\n\n\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\n\n\nNote how the output raster is smaller as the focal window is larger (edge effect)",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "raster-operations.html#focal-weights-1",
    "href": "raster-operations.html#focal-weights-1",
    "title": "Raster Operations",
    "section": "Focal weights (1)",
    "text": "Focal weights (1)\n\nThe focal weights we used above were square and evenly weighted\n\n\nfocal3by3\n\n     [,1] [,2] [,3]\n[1,]    1    1    1\n[2,]    1    1    1\n[3,]    1    1    1\n\n\n\nfocal11by11\n\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]\n [1,]    1    1    1    1    1    1    1    1    1     1     1\n [2,]    1    1    1    1    1    1    1    1    1     1     1\n [3,]    1    1    1    1    1    1    1    1    1     1     1\n [4,]    1    1    1    1    1    1    1    1    1     1     1\n [5,]    1    1    1    1    1    1    1    1    1     1     1\n [6,]    1    1    1    1    1    1    1    1    1     1     1\n [7,]    1    1    1    1    1    1    1    1    1     1     1\n [8,]    1    1    1    1    1    1    1    1    1     1     1\n [9,]    1    1    1    1    1    1    1    1    1     1     1\n[10,]    1    1    1    1    1    1    1    1    1     1     1\n[11,]    1    1    1    1    1    1    1    1    1     1     1",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "raster-operations.html#focal-weights-2",
    "href": "raster-operations.html#focal-weights-2",
    "title": "Raster Operations",
    "section": "Focal weights (2)",
    "text": "Focal weights (2)\n\nHowever, we can also create uneven weights:\n\nFor example, a laplacian filter is commonly used for edge detection.\n\nlaplacian &lt;- matrix(c(0,1,0,1,-4,1,0,1,0), nrow=3) \n\nlaplacian\n\n     [,1] [,2] [,3]\n[1,]    0    1    0\n[2,]    1   -4    1\n[3,]    0    1    0\n\n\nSo are the sobel filters\n\n\n     [,1] [,2] [,3]\n[1,]   -1    0    1\n[2,]   -2    0    2\n[3,]   -1    0    1\n\n\n     [,1] [,2] [,3]\n[1,]    1    2    1\n[2,]    0    0    0\n[3,]   -1   -2   -1\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.8: Laplacian Filter\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.9: Sobel (x-direction)\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.10: SObel (y-direction)",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "raster-operations.html#focal-weights-3",
    "href": "raster-operations.html#focal-weights-3",
    "title": "Raster Operations",
    "section": "Focal weights (3)",
    "text": "Focal weights (3)\n\nWe can also create specific shapes using weights\nWe don‚Äôt need to create these matrices by hand. Rather, we can use the function focalMat to create different shapes automatically\n\n\n# Note \n# - \"d\" is evaluated in the units of \"x\" (in our case: meters)\n# - The sum of all weights equals to 1\n# - Note how the edges receive a value of 0\nfocal_circle3000 &lt;- focalMat(x = r, d = 3000, \"circle\")\n\nfocal_circle3000\n\n           [,1]       [,2]       [,3]       [,4]       [,5]\n[1,] 0.00000000 0.00000000 0.03703704 0.00000000 0.00000000\n[2,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[3,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[4,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[5,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[6,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[7,] 0.00000000 0.00000000 0.03703704 0.00000000 0.00000000\n\n\n\n\n\n\n\nA visual representation of the matrix / filter above\n\n\n\n\n\nfocal_gauss1000 &lt;- focalMat(x = r, d = 1000, \"Gauss\")\n\nfocal_gauss1000\n\n            [,1]        [,2]        [,3]        [,4]        [,5]\n[1,] 0.000241551 0.001082556 0.001784834 0.001082556 0.000241551\n[2,] 0.002942693 0.013188236 0.021743725 0.013188236 0.002942693\n[3,] 0.013188236 0.059105572 0.097448614 0.059105572 0.013188236\n[4,] 0.021743725 0.097448614 0.160665602 0.097448614 0.021743725\n[5,] 0.013188236 0.059105572 0.097448614 0.059105572 0.013188236\n[6,] 0.002942693 0.013188236 0.021743725 0.013188236 0.002942693\n[7,] 0.000241551 0.001082556 0.001784834 0.001082556 0.000241551\n\n\n\n\n\n\n\nA visual representation of the matrix / filter above",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "raster-operations.html#focal-functions-in-terrain-processing",
    "href": "raster-operations.html#focal-functions-in-terrain-processing",
    "title": "Raster Operations",
    "section": "Focal functions in terrain processing",
    "text": "Focal functions in terrain processing\n\nFocal functions are used to calculate the slope of a specific location, e.g.¬†using the algorithm by Horn (1981)\nSimilarly, calculating the aspect (azimuth) of a location is a very typical task when dealing with elevation data\nThese algorithms are used so often, that they are implemented in a dedicated function (terrain())\n\nterrain(r, \"slope\") |&gt; plot()\nterrain(r, \"aspect\") |&gt; plot()\n\n\n\n\n\n\n\n\n\nFigure¬†7.11: Calculating slope using a predefined algorithm\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†7.12: Calculating aspect",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "raster-operations.html#tasks",
    "href": "raster-operations.html#tasks",
    "title": "Raster Operations",
    "section": "ü™ï Tasks",
    "text": "ü™ï Tasks\n\nImport the elevation of Luxembourg using the following code:\n\nr &lt;- rast(system.file(\"ex/elev.tif\", package=\"terra\"))\n\nCalculate the mean, maximum and minimum elevation values\nCalculate slope and aspect (see terrain functions)\nDetermine suitable locations of solar panels using the following conditions:\n\nElevation: above 300 MASL\nSlope: Between 1 and 3¬∞\nAspect: Southfacing (between 135 and 235¬∞)\n\nDownload the Municipalities of Luxembourg from Moodle and calculate the minimum, maximum and mean elevation values per municipality.\nSmooth the elevation values using different focal windows\nImport the multispectral Landsat 7 as a raster using the following path\n\nsystem.file(\"tif/L7_ETMs.tif\",package = \"stars\")\n\nCalculate the NDVI using the following formula:\n\n\\[\\text{NDVI} = \\frac{\\text{NIR}-\\text{red}}{\\text{NIR}+\\text{red}}\\]\n\n\n\n\n\nThe resulting NDVI values\n\n\n\n\n\n\n\n\nHorn, Berthold KP. 1981. ‚ÄúHill Shading and the Reflectance Map.‚Äù Proceedings of the IEEE 69 (1): 14‚Äì47.\n\n\nLovelace, Robin, Jakub Nowosad, and Jannes Muenchow. 2019. Geocomputation with r. Chapman; Hall/CRC.",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>7</span>¬† <span class='chapter-title'>Raster Operations</span>"
    ]
  },
  {
    "objectID": "raster-vector-operations.html",
    "href": "raster-vector-operations.html",
    "title": "Raster-Vector Operations",
    "section": "",
    "text": "Two worlds of spatial data",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "raster-vector-operations.html#two-worlds-of-spatial-data",
    "href": "raster-vector-operations.html#two-worlds-of-spatial-data",
    "title": "Raster-Vector Operations",
    "section": "",
    "text": "Till now, we have treated vector and raster data separately\nHowever, in many cases, you will need to combine both types of data\nFor example, take the Zonal operation we discussed previously (see Zonal): Typically, your ‚Äúzones‚Äù will be vector polygons",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "raster-vector-operations.html#zonal-operations-with-vector-data",
    "href": "raster-vector-operations.html#zonal-operations-with-vector-data",
    "title": "Raster-Vector Operations",
    "section": "Zonal operations with vector data",
    "text": "Zonal operations with vector data\n\nThe zonal function in {terra} can handle vector data: however, it requires sf objects to be converted to terra‚Äôs own vector format, called SpatVector. - The function vect() can be used to convert sf objects to SpatVector objects:\n\n\nmean_vals &lt;- zonal(r, vect(zones), fun = mean, na.rm = TRUE)\n\n\nzones$mean &lt;- mean_vals$elevation\n\n\n\n\n\n\n\n\n\n\nFigure¬†8.1: The original raster data\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†8.2: The original zones as vector polygons\n\n\n\n\n\n\n\n\n\n\n\nFigure¬†8.3: The resulting zones (mean elevation per zone), also as vector data",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "raster-vector-operations.html#extracting-raster-values-at-vector-points",
    "href": "raster-vector-operations.html#extracting-raster-values-at-vector-points",
    "title": "Raster-Vector Operations",
    "section": "Extracting raster values at vector points",
    "text": "Extracting raster values at vector points\n\nA another common operation is to extract raster values at specific points\nLet‚Äôs take the example of the city of Luxembourg (see Global Operation (2))\nThe function extract() can be used to extract raster values at specific points\nextract returns a data.frame with\n\none column per raster band (1 in our case)\none row per point (also 1 in our case):\n\n\n\n\n\n\n\n\n\n\n\n\nlux_elev &lt;- extract(r, luxembourg_city)\nlux_elev\n\n  ID elevation\n1  1  293.9805",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "raster-vector-operations.html#vector-to-raster-conversion",
    "href": "raster-vector-operations.html#vector-to-raster-conversion",
    "title": "Raster-Vector Operations",
    "section": "Vector to raster conversion",
    "text": "Vector to raster conversion\n\nFunctions that combine raster and vector data usually convert vector to raster internally\nSometimes, we might want to do this conversion explicitly. This can be done using the rasterize() function\nThis function takes three arguments:\n\nx: The vector data (either of class sf or SpatVector)\ny: A raster object that defines the extent, resolution, and CRS of the resulting raster (i.e.¬†a ‚Äútemplate‚Äù)\nfield: The name of the column in the vector data that should be used to fill the raster cells\n\n\n\n# we can create a template using the input vector. All we have to specify \n# is the resolution of the output raster, which is evalutated in the units of\n# the CRS of the input vector data (meters in our case).\n\ntemplate &lt;- rast(zones, resolution = 1000)\n\nzones_raster &lt;- rasterize(zones, template, \"zone\")\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) The original zones as polygon data\n\n\n\n\n\n\n\n\n\n\n\n(b) The zones as raster data\n\n\n\n\n\n\n\nFigure¬†8.4: Note how the conversion to polygons results in a loss of detail\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\nNote that rasters don‚Äôt store character information. The above zones are coded as integers with a corresponding look-up table (see ?terra::levels).",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "raster-vector-operations.html#raster-to-vector-conversion",
    "href": "raster-vector-operations.html#raster-to-vector-conversion",
    "title": "Raster-Vector Operations",
    "section": "Raster to vector conversion",
    "text": "Raster to vector conversion\n\nThe opposite operation, converting raster data to vector data, can be done using the {terra} functions as.points, as.lines and as.polygons:\nThe resulting object will be of class SpatVector. This can be converted to the sf class using st_as_sf()\n\n\nzones_poly &lt;- as.polygons(zones_raster) |&gt; \n  st_as_sf()\n\n\n\n\n\n\n\n\n\n\n\n\n\n(a) The zones as raster data\n\n\n\n\n\n\n\n\n\n\n\n(b) The zones as polygon data\n\n\n\n\n\n\n\nFigure¬†8.5: Note how the conversion back to polygons preserves the cell boundaries",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "raster-vector-operations.html#tasks",
    "href": "raster-vector-operations.html#tasks",
    "title": "Raster-Vector Operations",
    "section": "ü™ï Tasks",
    "text": "ü™ï Tasks\n\nImport Arealstatistik.gpkg from Spatial_Analysis_II using {sf}\nTo rasterize the data, we need a template raster object. Create a template raster object with a resolution of 100m using the rast() function\nRasterize the arealstatistik data using the function rasterize, the tempalte from the previous step, and the column AS_4 as the field to fill the raster cells\n\n\nThe resulting raster contains the integer values 1 to 4. These values correspond to the following land use categories (see metadata):\n\nSettlement and urban areas\nAgricultural areas\nWooded areas\nUnproductive areas\n\n\nTo make the raster more interpretable, assign the corresponding names to the levels of the raster using the levels() function. The levels should be a data.frame with two columns: ID and name (see below)\n\nlevs &lt;- data.frame(\n  ID = 1:4, \n  name = c(\n    \"Settlement and urban areas\", \n    \"Agricultural areas\", \n    \"Wooded areas\", \n    \"Unproductive areas\"\n    ) \n  )\n\nlevels(areal_rast) &lt;- levs\n\nplot(areal_rast)",
    "crumbs": [
      "Raster Data Lecture",
      "<span class='chapter-number'>8</span>¬† <span class='chapter-title'>Raster-Vector Operations</span>"
    ]
  },
  {
    "objectID": "raster-data-exercise.html",
    "href": "raster-data-exercise.html",
    "title": "Raster Data Exercise",
    "section": "",
    "text": "Introduction\nIn this exercise, you will develop a spatial habitat suitability model to identify potential chamois habitats in the Canton of Lucerne. This multi-criteria analysis will combine your knowledge of vector and raster data processing, spatial analysis, and ecological modeling.",
    "crumbs": [
      "Raster Data Exercises",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Raster Data Exercise</span>"
    ]
  },
  {
    "objectID": "raster-data-exercise.html#introduction",
    "href": "raster-data-exercise.html#introduction",
    "title": "Raster Data Exercise",
    "section": "",
    "text": "Ecological Background\nChamois (Rupicapra rupicapra) are mountain ungulates native to European mountain ranges. Understanding their habitat requirements is crucial for conservation planning. Based on ecological research, chamois have the following habitat requirements:\n\nHome range size: Approximately 1 km¬≤\nForest cover: Require sufficient forest within their home range for refuge and thermal protection\nSteep terrain: Need steep areas (&gt; 30¬∞) where they have physiological advantages over predators\nHuman disturbance: Avoid human settlements and heavily trafficked roads\n\n\n\nAnalytical Workflow\nFigure¬†9.1 shows the complete workflow for this analysis. Study this process model carefully - it will guide you through the entire exercise. The process model is also available as a high-resolution PDF on Moodle.\n\n\n\n\n\n\nFigure¬†9.1: Process model for chamois habitat suitability analysis\n\n\n\n\n\n\n\n\n\nTipWorking with the Process Model\n\n\n\nBefore you begin, take time to understand:\n\nWhat input datasets are needed?\nWhat geoprocessing steps will you perform?\nHow do the steps connect to each other?\nWhat is the final output?\n\n\n\nYour task is to implement this workflow using R, combining vector and raster analysis techniques to produce a habitat suitability map.",
    "crumbs": [
      "Raster Data Exercises",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Raster Data Exercise</span>"
    ]
  },
  {
    "objectID": "raster-data-exercise.html#task-1-data-exploration-and-project-setup",
    "href": "raster-data-exercise.html#task-1-data-exploration-and-project-setup",
    "title": "Raster Data Exercise",
    "section": "Task 1: Data Exploration and Project Setup",
    "text": "Task 1: Data Exploration and Project Setup\n\nSetup Your Workspace\n\nCreate a new R Project\nDownload the exercise data from Moodle (section ‚ÄúCW 39 ‚Äì Spatial Analysis II‚Äù)\nExtract the data into your new folder\nCreate a new R script or Quarto document for this exercise\n\n\n\nUnderstanding Your Data\nYour downloaded data folder contains several datasets:\n\n\n\n\n\n\nNoteInput Datasets\n\n\n\n\nRaster data:\n\ndhm25_lu.tif - Digital elevation model at 25m resolution\n\nVector data (in GeoPackages):\n\ntlm_bb (polygon layer) - Land cover classification from swiss_TLM3.gpkg\ntlm_strassen (line layer) - Road network from swiss_TLM3.gpkg\narealstatistik (point layer) - Swiss land use statistics from Arealstatistik.gpkg\nkantonsgebiet_lu (polygon layer) - Canton boundary from swissBOUNDARIES3D.gpkg\n\n\n\n\n\n\nMetadata Resources\nUnderstanding your data is crucial for proper analysis. Familiarize yourself with these metadata sources:\n\nDHM25: Data source & description\nswissTLM3D: Data source & description | Objektkatalog (2024)\nArealstatistik BFS: Data source & description | Nomenklatur 72 Grundkategorien\n\n\n\n\n\n\n\nTipHint: Required R Packages\n\n\n\nYou‚Äôll need the following packages for this exercise:\n\nsf for vector data\nterra for raster data\ndplyr for data manipulation\nggplot2 or tmap for visualisation\n\n\n\n\n\nYour First Tasks\nLoad the data and explore its properties. Consider these questions:\n\nWhat coordinate reference system (CRS) are the datasets using?\nWhat is the spatial extent and resolution of the elevation model?\nWhat attributes are available in each vector layer?\nDo all datasets cover the same geographic area?\n\nCreate a visualization to familiarize yourself with the data.",
    "crumbs": [
      "Raster Data Exercises",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Raster Data Exercise</span>"
    ]
  },
  {
    "objectID": "raster-data-exercise.html#task-2-create-a-forest-cover-raster",
    "href": "raster-data-exercise.html#task-2-create-a-forest-cover-raster",
    "title": "Raster Data Exercise",
    "section": "Task 2: Create a Forest Cover Raster",
    "text": "Task 2: Create a Forest Cover Raster\nObjective: Convert the vector-based land cover layer (tlm_bb) into a raster format that represents forest areas. This raster will serve as one of your habitat suitability criteria.\nBackground: Before proceeding, consult the swissTLM3D Objektkatalog to understand the classification system. The land use types are stored in the field ‚ÄúOBJEKTART‚Äù (see TOPIC TLM_BB).\n\n\n\n\n\n\nImportantThink About This\n\n\n\nWhich OBJEKTART categories represent forest that chamois would use for refuge? Consider different forest types and their characteristics.\n\n\n\nWorkflow Steps\nYour task involves several sequential operations:\n\nSelect forest features - Filter the tlm_bb layer to extract only forest-related land cover types\nDissolve boundaries - Merge all forest polygons into a single multipart feature\nRasterize - Convert the vector layer to raster format using the DHM25 as a template\nValidate - Examine the output to ensure it‚Äôs correct\n\n\n\n\n\n\n\nTipHint: Forest Categories\n\n\n\nFor this analysis, consider these forest types as suitable chamois habitat: - Geb√ºschwald - Wald - Wald offen\n\n\n\n\n\n\n\n\nTipHint: Vector to Raster Conversion\n\n\n\n\n\nWhen rasterizing: - Use the DHM25 as a template to ensure matching extent and resolution - The terra package has a rasterize() function - You may need to convert sf objects to terra‚Äôs vect format - Consider what value to assign to forest cells (e.g., 1 = forest)\n\n\n\n\n\n\n\n\n\nNoteReflection Question\n\n\n\nExamine the properties of your forest_raster. Is it an integer or floating-point raster? What values does it contain? Why might this matter for subsequent analyses?",
    "crumbs": [
      "Raster Data Exercises",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Raster Data Exercise</span>"
    ]
  },
  {
    "objectID": "raster-data-exercise.html#task-3-derive-terrain-slope",
    "href": "raster-data-exercise.html#task-3-derive-terrain-slope",
    "title": "Raster Data Exercise",
    "section": "Task 3: Derive Terrain Slope",
    "text": "Task 3: Derive Terrain Slope\nObjective: Calculate slope from the digital elevation model. Slope is a critical habitat parameter - chamois use steep terrain as refuges where they have physiological advantages over predators.\nBackground: Slope represents the rate of change in elevation and can be calculated from a DEM using neighborhood operations. The terra package provides the terrain() function for this purpose.\n\n\n\n\n\n\nTipHint: Terrain Analysis\n\n\n\n\n\n\nThe terrain() function requires specifying which terrain variable to calculate (e.g., ‚Äúslope‚Äù, ‚Äúaspect‚Äù)\nChoose appropriate units for your analysis (degrees vs.¬†radians)\nThe output will be a floating-point raster\n\n\n\n\n\n\n\n\n\n\nNoteReflection Questions\n\n\n\n\nWhat data type is the slope raster? Why does this differ from the forest raster?\nWhat is the steepest slope in your study area? Is this realistic?\nWhere would you expect to find the steepest slopes?",
    "crumbs": [
      "Raster Data Exercises",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Raster Data Exercise</span>"
    ]
  },
  {
    "objectID": "raster-data-exercise.html#task-4-identify-steep-terrain",
    "href": "raster-data-exercise.html#task-4-identify-steep-terrain",
    "title": "Raster Data Exercise",
    "section": "Task 4: Identify Steep Terrain",
    "text": "Task 4: Identify Steep Terrain\nObjective: Reclassify the continuous slope values into a binary classification: steep vs.¬†non-steep areas. Based on ecological studies, chamois benefit from slopes steeper than 30¬∞.\nBackground: Reclassification transforms continuous data into categorical classes. You‚Äôll create a binary raster where: - 0 = non-steep areas (0-30¬∞) - 1 = steep areas (&gt;30¬∞)\n\n\n\n\n\n\nTipHint: Reclassification in terra\n\n\n\n\n\nThe classify() function uses a reclassification matrix with three columns: - Column 1: Lower bound of range - Column 2: Upper bound of range - Column 3: New value to assign\nRemember to use include.lowest = TRUE to handle boundary values correctly.",
    "crumbs": [
      "Raster Data Exercises",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Raster Data Exercise</span>"
    ]
  },
  {
    "objectID": "raster-data-exercise.html#task-5-extract-high-traffic-roads",
    "href": "raster-data-exercise.html#task-5-extract-high-traffic-roads",
    "title": "Raster Data Exercise",
    "section": "Task 5: Extract High-Traffic Roads",
    "text": "Task 5: Extract High-Traffic Roads\nObjective: Identify heavily trafficked roads that chamois would avoid. While we don‚Äôt have direct traffic volume data, we can use road type as a proxy for traffic intensity.\nBackground: Consult the swissTLM3D Objektkatalog to understand the road classification system. The OBJEKTART field contains road type information, and the KUNSTBAUTE field indicates infrastructure like tunnels.\n\n\n\n\n\n\nImportantImportant Consideration\n\n\n\nWhy should roads in tunnels be excluded from this analysis? Think about how chamois would perceive and respond to different road types.\n\n\n\n\n\n\n\n\nTipHint: Road Types to Consider\n\n\n\nMajor road types that typically carry high traffic: - Autobahn (highways) - Autostrasse (expressways) - 10m, 8m, 6m, 4m Strasse (roads classified by width) - Einfahrt, Ausfahrt, Zufahrt (on/off ramps and access roads)\nExclude roads where KUNSTBAUTE equals ‚ÄúTunnel‚Äù.",
    "crumbs": [
      "Raster Data Exercises",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Raster Data Exercise</span>"
    ]
  },
  {
    "objectID": "raster-data-exercise.html#task-6-delineate-settlement-areas",
    "href": "raster-data-exercise.html#task-6-delineate-settlement-areas",
    "title": "Raster Data Exercise",
    "section": "Task 6: Delineate Settlement Areas",
    "text": "Task 6: Delineate Settlement Areas\nObjective: Create a spatial layer representing human settlement areas that chamois would avoid. You‚Äôll use the Swiss Land Use Statistics (Arealstatistik) dataset for this purpose.\nBackground: The Arealstatistik provides detailed land use information at the hectare level. The dataset uses a classification system with 72 basic categories (see Nomenklatur 72 Grundkategorien).\n\n\n\n\n\n\nImportantYour Task: Define Settlement Areas\n\n\n\nBefore looking at the hint below, download and examine the variable list (xlsx-file) - specifically the sheet ‚ÄúCodes AS_72‚Äù.\nThink about: Which categories represent areas where human activity would disturb chamois? Consider different types of buildings and their surroundings (in German, ‚ÄúUmschwung‚Äù refers to the area immediately surrounding buildings).\n\n\n\n\n\n\n\n\nTipHint: Settlement Categories (AS_72 codes)\n\n\n\n\n\nFor this analysis, consider these categories as settlement areas: - 1: Industrie- und Gewerbegeb√§ude - 2: Umschwung von Industrie- und Gewerbegeb√§uden - 3: Ein- und Zweifamilienh√§user - 4: Umschwung von Ein- und Zweifamilienh√§usern - 5: Reihen- und Terrassenh√§user - 6: Umschwung von Reihen- und Terrassenh√§usern - 7: Mehrfamilienh√§user - 8: Umschwung von Mehrfamilienh√§usern - 9: √ñffentliche Geb√§ude - 10: Umschwung von √∂ffentlichen Geb√§uden - 11: Landwirtschaftliche Geb√§ude - 13: Nicht spezifizierte Geb√§ude\n\n\n\n\nWorkflow\nYour analysis should:\n\nFilter the Arealstatistik points to extract settlement-related categories\nBuffer these points by 150 meters (representing a zone of human influence)\nDissolve overlapping buffers to create contiguous settlement areas\n\n\n\n\n\n\n\nNoteWhy Buffer?\n\n\n\nThe Arealstatistik uses point samples at hectare intervals. Buffering creates a more realistic representation of settlement extent and the zone of human disturbance around settlements.",
    "crumbs": [
      "Raster Data Exercises",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Raster Data Exercise</span>"
    ]
  },
  {
    "objectID": "raster-data-exercise.html#task-7-analyze-local-habitat-characteristics",
    "href": "raster-data-exercise.html#task-7-analyze-local-habitat-characteristics",
    "title": "Raster Data Exercise",
    "section": "Task 7: Analyze Local Habitat Characteristics",
    "text": "Task 7: Analyze Local Habitat Characteristics\nObjective: Evaluate the landscape surrounding every location in terms of forest cover and steep terrain availability. This analysis accounts for the chamois home range size (~1 km¬≤) by examining the local neighborhood around each potential habitat location.\n\nConceptual Background\nChamois don‚Äôt just need forest and steep slopes - they need sufficient amounts of these resources within their home range. A focal (moving window) analysis evaluates each cell by examining its neighborhood, essentially asking: ‚ÄúIf a chamois lived here, would there be enough resources within its typical home range?‚Äù\n\n\n\n\n\n\nImportantThink About This\n\n\n\n\nWhy is it not enough to simply identify where forests and steep slopes exist?\nHow does home range size influence habitat suitability?\nWhat does it mean if a location has high forest cover within 1 km¬≤ but no steep slopes nearby?\n\n\n\n\n\nData Preparation\nBefore conducting focal statistics, you need to handle NA (no data) values. Binary rasters (forest/non-forest, steep/non-steep) need to explicitly represent ‚Äúabsence‚Äù as 0 rather than NA.\n\n\n\n\n\n\nTipHint: Replacing NA Values\n\n\n\n\n\nUse the classify() function with a reclassification matrix that maps NA to 0:\nnew_raster &lt;- classify(old_raster, cbind(NA, 0))\n\n\n\n\n\nCalculate Window Size\nTo represent a 1 km¬≤ home range, you need to determine the appropriate window size in raster cells.\n\n\n\n\n\n\nNoteMathematical Approach\n\n\n\nGiven: - Home range area = 1 km¬≤ = 1,000,000 m¬≤ - Raster resolution = 25m √ó 25m = 625 m¬≤ per cell - Number of cells needed = 1,000,000 m¬≤ √∑ 625 m¬≤/cell = ? - Window dimensions (assuming square window) = ‚àö(number of cells) = ?\nCalculate this yourself, then check the code below.\n\n\n\n\nPerform Focal Analysis\nThe focal analysis counts how many forest cells (or steep cells) exist within the moving window around each location.\n\n\n\n\n\n\nTipHint: Focal Analysis in terra\n\n\n\n\n\nThe focal() function requires: - Input raster - Weight matrix (w) - use matrix(1, nrow=size, ncol=size) for equal weights - Function to apply (fun = \"sum\" to count cells with value 1) - na.rm = TRUE to handle any remaining NA values\n\n\n\n\n\n\n\n\nFocal analysis results showing local resource availability\n\n\n\n\nFigure¬†9.2\n\n\n\n\n\n\n\n\n\nNoteInterpret Your Results\n\n\n\nThe output values typically range from 0 to ~1500-1600.\nThink about: - What does a value of 0 mean? What about 1600? - Why might the maximum be less than 1600 (the theoretical maximum)? - Which areas have the highest forest counts? Highest steep terrain counts? - How do these patterns relate to the topography of Canton Lucerne?",
    "crumbs": [
      "Raster Data Exercises",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Raster Data Exercise</span>"
    ]
  },
  {
    "objectID": "raster-data-exercise.html#task-8-calculate-distance-to-human-disturbance",
    "href": "raster-data-exercise.html#task-8-calculate-distance-to-human-disturbance",
    "title": "Raster Data Exercise",
    "section": "Task 8: Calculate Distance to Human Disturbance",
    "text": "Task 8: Calculate Distance to Human Disturbance\nObjective: Quantify how far each location is from human disturbance sources (settlements and major roads). Chamois are sensitive to human activity, so greater distances should indicate better habitat quality.\nBackground: Distance calculations create continuous surfaces where each cell‚Äôs value represents its proximity to the nearest feature. This allows you to model avoidance behavior - animals may select habitat based on distance to disturbance sources.\n\n\n\n\n\n\nImportantConceptual Question\n\n\n\nHow is a distance-based criterion different from the binary (present/absent) classification we used for forest and steep areas? Why use distance rather than simply excluding areas near roads and settlements?\n\n\n\nWorkflow\nTo calculate distances in a raster environment:\n\nRasterize vector features (roads and settlements)\nCalculate Euclidean distance from each cell to the nearest feature\nAnalyze the resulting distance surfaces\n\n\n\n\n\n\n\nTipHint: Distance Calculation\n\n\n\n\n\nThe terra distance() function: - Takes a raster where features are marked with values (typically 1) - Calculates the straight-line distance from each cell to the nearest non-NA cell - Returns distances in map units (meters for EPSG:2056)\n\n\n\n\n\n\n\n\nDistance surfaces from human disturbance sources\n\n\n\n\nFigure¬†9.3\n\n\n\n\n\n\n\n\n\nNoteReflection Questions\n\n\n\n\nWhat are the maximum distances to roads and settlements in your study area?\nWhere would you expect to find the most remote areas?\nHow might chamois use areas at different distances from human activity?\nCould there be areas that are too remote for chamois? What other factors might limit habitat beyond distance to disturbance?",
    "crumbs": [
      "Raster Data Exercises",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Raster Data Exercise</span>"
    ]
  },
  {
    "objectID": "raster-data-exercise.html#task-9-standardize-criteria-to-common-scale",
    "href": "raster-data-exercise.html#task-9-standardize-criteria-to-common-scale",
    "title": "Raster Data Exercise",
    "section": "Task 9: Standardize Criteria to Common Scale",
    "text": "Task 9: Standardize Criteria to Common Scale\nObjective: Transform all four habitat criteria onto a common suitability scale, enabling meaningful comparison and combination of different environmental factors.\n\nThe Standardization Problem\nYou now have four criteria measured in different units: - focal_forest: count of forest cells (0-1600) - focal_steepness: count of steep cells (0-1600) - distance_roads: meters (0-several thousand) - distance_settlement: meters (0-several thousand)\n\n\n\n\n\n\nImportantCritical Question\n\n\n\nWhy can‚Äôt we directly combine these raw values? What problems would arise if we simply added them together?\nConsider: - A location with 500 forest cells + 500 steep cells + 5000m from roads + 3000m from settlements = 9000 - Another location with 100 forest cells + 100 steep cells + 200m from roads + 100m from settlements = 500\nDoes the first location really have 18√ó better habitat? How do the different measurement units affect interpretation?\n\n\n\n\nSolution: Suitability Classification (Grading)\nStandardize all criteria using a common five-class suitability scale:\n\n1 = unsuitable\n2 = conditionally suitable\n3 = moderately suitable\n4 = well suitable\n5 = very well suitable\n\n\n\nClassification Thresholds\nThe following thresholds are based on ecological considerations and expert knowledge:\n\nForest CoverSteep TerrainRoad DistanceSettlement Distance\n\n\nfocal_forest (cell count within 1 km¬≤):\n\n0 - 300 ‚Üí 1 (unsuitable: &lt;20% forest)\n300 - 600 ‚Üí 2 (conditional: 20-37%)\n600 - 900 ‚Üí 3 (moderate: 37-56%)\n900 - 1200 ‚Üí 4 (good: 56-75%)\n1200 - 2000 ‚Üí 5 (excellent: &gt;75%)\n\n\n\nfocal_steepness (cell count within 1 km¬≤):\n\n0 - 200 ‚Üí 1 (unsuitable: &lt;12% steep)\n200 - 400 ‚Üí 2 (conditional: 12-25%)\n400 - 600 ‚Üí 3 (moderate: 25-37%)\n600 - 800 ‚Üí 4 (good: 37-50%)\n800 - 2000 ‚Üí 5 (excellent: &gt;50%)\n\n\n\ndistance_roads (meters):\n\n0 - 150 ‚Üí 1 (unsuitable: very close)\n150 - 300 ‚Üí 2 (conditional: close)\n300 - 450 ‚Üí 3 (moderate: medium distance)\n450 - 600 ‚Üí 4 (good: far)\n600 - 20000 ‚Üí 5 (excellent: very far)\n\n\n\ndistance_settlement (meters):\n\n0 - 250 ‚Üí 1 (unsuitable: very close)\n250 - 500 ‚Üí 2 (conditional: close)\n500 - 750 ‚Üí 3 (moderate: medium distance)\n750 - 1000 ‚Üí 4 (good: far)\n1000 - 20000 ‚Üí 5 (excellent: very far)\n\n\n\n\n\n\n\n\n\n\nNoteThink About the Thresholds\n\n\n\nThese classifications represent ecological hypotheses about chamois habitat preferences.\nQuestions to consider: - Are these thresholds reasonable? - How might you validate or refine them? - Should all criteria have equal weight in the final analysis? - How sensitive might the results be to these classification boundaries?\n\n\n\n\nPerform the Reclassifications\nNow apply these classification schemes to each criterion. You‚Äôll use the same reclassification approach you learned earlier.\n\n\nVisualize and Compare\nExamine all four standardized criteria side-by-side:\n\n\n\n\n\n\nNoteCompare the Patterns\n\n\n\nNow that all criteria are on the same scale (1-5), you can meaningfully compare them.\nLook for: - Which criterion shows the most variability? - Which areas score high on multiple criteria? - Are there any surprising patterns? - How do topographic factors (forest, slope) relate to human factors (roads, settlements)?",
    "crumbs": [
      "Raster Data Exercises",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Raster Data Exercise</span>"
    ]
  },
  {
    "objectID": "raster-data-exercise.html#task-10-multi-criteria-overlay-analysis",
    "href": "raster-data-exercise.html#task-10-multi-criteria-overlay-analysis",
    "title": "Raster Data Exercise",
    "section": "Task 10: Multi-Criteria Overlay Analysis",
    "text": "Task 10: Multi-Criteria Overlay Analysis\nObjective: Combine all four standardized criteria into a single habitat suitability map using raster overlay analysis.\n\nConceptual Background\nNow that all criteria are on a common 1-5 scale, you can combine them to identify areas that satisfy multiple habitat requirements simultaneously. This is the essence of Multi-Criteria Evaluation (MCE).\n\n\n\n\n\n\nImportantThink About the Method\n\n\n\nWe‚Äôll use a simple additive model (sum of all criteria).\nConsider: - What assumptions does this make about how criteria interact? - Does it assume all criteria are equally important? - Could two moderate scores compensate for one poor score? - What‚Äôs the theoretical range of output values? (Min = ?, Max = ?)\n\n\n\n\nPerform the Overlay\nOne of the great advantages of raster data is that map algebra is straightforward - you can use standard arithmetic operators:\n\n\nAnalyze the Results\n\n\n\n\n\n\nNoteInterpret the Value Range\n\n\n\nThe sum values range from 4 (all criteria scored 1) to 20 (all criteria scored 5).\nWhat does this mean? - 4-8: Poor habitat - multiple limiting factors - 9-14: Moderate habitat - mixed conditions - 15-20: Excellent habitat - all requirements met\nDo you observe the full range in your study area? Why or why not?\n\n\n\n\nVisualize the Habitat Suitability Map\n\n\nCreate Simplified Classification\nFor management and communication purposes, create a three-class version:\n\n\n\n\n\n\nNoteGeographic Patterns\n\n\n\nExamine your final map carefully:\n\nWhere are the most suitable habitats located?\nWhat geographic features characterize high-suitability areas?\nAre there surprising results? Areas you expected to be suitable that aren‚Äôt, or vice versa?\nHow contiguous are the suitable habitat patches?",
    "crumbs": [
      "Raster Data Exercises",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Raster Data Exercise</span>"
    ]
  },
  {
    "objectID": "raster-data-exercise.html#task-11-model-validation-and-critical-evaluation",
    "href": "raster-data-exercise.html#task-11-model-validation-and-critical-evaluation",
    "title": "Raster Data Exercise",
    "section": "Task 11: Model Validation and Critical Evaluation",
    "text": "Task 11: Model Validation and Critical Evaluation\nObjective: Critically evaluate your habitat suitability model by comparing it with actual chamois distribution data and calculating quantitative statistics.\n\nFinal Data Processing\nCreate a final, polished version of your suitability map:\n\n\nCalculate Habitat Availability\nQuantify how much suitable habitat exists in each suitability class:\n\n\n\n\n\n\nNoteInterpret the Statistics\n\n\n\n\nWhat percentage of Canton Lucerne is ‚Äúhighly suitable‚Äù for chamois?\nHow much area is in each category?\nDoes this match your expectations based on the canton‚Äôs geography?\n\n\n\n\n\nCompare with Actual Distribution\nNow validate your model against reality. Visit the Info Fauna database to view actual chamois observations:\nChamois Distribution Map - Info Fauna\n\n\n\n\n\n\nImportantCritical Evaluation\n\n\n\nCompare your suitability map with the actual distribution:\nQuestions to consider: 1. Do areas with high predicted suitability show actual chamois presence? 2. Are there areas you predicted as suitable but have no observations? Why might this be? 3. Are there observed chamois in areas your model predicts as unsuitable? What factors might your model be missing? 4. How well does your model capture the overall distribution pattern? 5. What are the main sources of agreement and disagreement?\nImportant: Absence of observations doesn‚Äôt always mean absence of animals - consider sampling effort, accessibility, and data reporting biases.",
    "crumbs": [
      "Raster Data Exercises",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Raster Data Exercise</span>"
    ]
  },
  {
    "objectID": "raster-data-exercise.html#critical-discussion",
    "href": "raster-data-exercise.html#critical-discussion",
    "title": "Raster Data Exercise",
    "section": "Critical Discussion",
    "text": "Critical Discussion\n\nModel Limitations and Improvements\n\n\n\n\n\n\nWarningReflect on Your Methodology\n\n\n\nYour model makes several simplifying assumptions. Consider these limitations and potential improvements:\n\n\n\n1. Equal Weighting of Criteria\nCurrent approach: All four criteria contribute equally (simple sum).\nQuestions: - Is forest cover really as important as distance to settlements? - Should steep terrain be weighted more heavily, as it‚Äôs a primary anti-predator strategy? - How could you determine appropriate weights?\n\n\n\n\n\n\nTipHint: Weighted Overlay\n\n\n\n\n\nYou could modify the overlay to use weights:\n# Example: assign different importance weights\nweighted_suitability &lt;- 0.3*grading_forest + 0.3*grading_steepness +\n                        0.2*grading_roads + 0.2*grading_settlement\n\n\n\n\n\n2. Classification Thresholds\nCurrent approach: Fixed thresholds based on general ecological principles.\nImprovements: - Calibrate thresholds using actual chamois location data - Use statistical methods (e.g., resource selection functions) - Incorporate uncertainty in threshold definitions - Test sensitivity to different threshold values\n\n\n3. Missing Criteria\nWhat factors did we omit?\n\nEnvironmentalHuman ImpactBiotic Interactions\n\n\n\nElevation: Chamois prefer specific elevation ranges (typically 1000-3000m in Alps)\nAspect: South-facing slopes have less snow and earlier vegetation\nVegetation type: Not all forests are equal - species composition matters\nSnow depth: Critical for winter survival and accessibility\nRock/cliff presence: Provides additional escape terrain\n\n\n\n\nRecreation areas: Hiking trails, ski resorts, climbing areas\nSeasonal access: Different impacts in winter vs.¬†summer\nHunting pressure: Legal hunting affects distribution\nHistorical presence: Where have chamois traditionally been?\n\n\n\n\nPredators: Lynx, wolf distribution\nCompetitors: Red deer, ibex overlap\nDisease: Presence of keratoconjunctivitis or other diseases\n\n\n\n\n\n\n4. Compensatory vs.¬†Limiting Factors\nCurrent model: Allows compensation - high scores on some criteria can offset low scores on others.\nEcological reality: Some factors may be limiting - absolutely required regardless of other conditions.\n\n\n\n\n\n\nImportantThink About This\n\n\n\nShould the model allow an area with zero steep terrain but excellent forest cover to be classified as ‚Äúsuitable‚Äù? Or is steep terrain a non-negotiable requirement?\nYou could implement threshold constraints:\n# Example: require minimum steepness\nsuitable_habitat &lt;- grading_sum\nsuitable_habitat[grading_steepness &lt; 3] &lt;- NA  # Exclude areas without adequate steep terrain\n\n\n\n\n\nData Quality Considerations\n\nSpatial Resolution\n\nIs 25m appropriate for modeling home ranges of ~1 km¬≤?\nHow does resolution affect focal analysis results?\n\n\n\nTemporal Mismatch\n\nAre all datasets from the same time period?\nHave land use patterns changed since data collection?\n\n\n\nData Accuracy\n\nHow accurate is the land cover classification?\nAre road and settlement data complete and current?\n\n\n\n\nScale Dependencies\n\n\n\n\n\n\nNoteMulti-Scale Considerations\n\n\n\nChamois habitat selection operates at multiple scales: - Regional scale: Climate, elevation zones - Landscape scale: Home range characteristics (what we modeled) - Local scale: Specific feeding sites, bedding areas\nYour model addresses primarily the landscape scale. Results might differ at other scales.",
    "crumbs": [
      "Raster Data Exercises",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Raster Data Exercise</span>"
    ]
  },
  {
    "objectID": "raster-data-exercise.html#extension-ideas",
    "href": "raster-data-exercise.html#extension-ideas",
    "title": "Raster Data Exercise",
    "section": "Extension Ideas",
    "text": "Extension Ideas\nIf you want to take this analysis further:\n\n1. Remove Water Bodies\n\n\n2. Add Elevation Constraints\n\n\n3. Conduct Sensitivity Analysis\nTest how results change with different: - Classification thresholds - Criterion weights - Home range window sizes - Inclusion/exclusion of criteria\n\n\n4. Validate Quantitatively\nIf you have access to presence/absence data: - Calculate AUC (Area Under Curve) or similar metrics - Perform cross-validation - Test predictive accuracy",
    "crumbs": [
      "Raster Data Exercises",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Raster Data Exercise</span>"
    ]
  },
  {
    "objectID": "raster-data-exercise.html#concluding-thoughts",
    "href": "raster-data-exercise.html#concluding-thoughts",
    "title": "Raster Data Exercise",
    "section": "Concluding Thoughts",
    "text": "Concluding Thoughts\n\n\n\n\n\n\nImportantProfessional Responsibility\n\n\n\nAs a GIS analyst, you must:\n‚úì Acknowledge limitations - No model is perfect; be transparent about assumptions and constraints ‚úì Validate results - Compare predictions with empirical data whenever possible ‚úì Consider context - Understand the ecology, not just the technical methods ‚úì Communicate uncertainty - Decision-makers need to know confidence levels ‚úì Document thoroughly - Future users must understand your methodology\nRemember: A beautiful map doesn‚Äôt necessarily represent reality. Critical thinking and validation are essential.",
    "crumbs": [
      "Raster Data Exercises",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Raster Data Exercise</span>"
    ]
  },
  {
    "objectID": "raster-data-exercise.html#summary-of-key-concepts",
    "href": "raster-data-exercise.html#summary-of-key-concepts",
    "title": "Raster Data Exercise",
    "section": "Summary of Key Concepts",
    "text": "Summary of Key Concepts\nThrough this exercise, you‚Äôve learned:\n\nVector to raster conversion - Transforming different data types for analysis\nTerrain analysis - Deriving slope from elevation data\nReclassification - Converting continuous and categorical data\nFocal analysis - Neighborhood operations for landscape context\nDistance calculation - Euclidean distance surfaces\nMulti-criteria evaluation - Standardization and overlay of disparate criteria\nModel validation - Comparing predictions with observations\nCritical evaluation - Understanding limitations and assumptions\n\nThese skills are fundamental to spatial analysis and transferable to many other applications beyond wildlife habitat modeling.",
    "crumbs": [
      "Raster Data Exercises",
      "<span class='chapter-number'>9</span>¬† <span class='chapter-title'>Raster Data Exercise</span>"
    ]
  }
]