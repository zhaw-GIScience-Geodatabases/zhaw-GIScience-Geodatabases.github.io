{
  "hash": "17d40c8e37d3da28ff576cfd0fbb4578",
  "result": {
    "engine": "knitr",
    "markdown": "---\necho: false\n---\n\n\n# Raster-Vector Operations\n\n::: {.cell}\n\n:::\n\n\n## Two worlds of spatial data\n\n- Till now, we have treated vector and raster data separately\n- However, in many cases, you will need to combine both types of data\n- For example, take the Zonal operation we discussed previously [(see @sec-zonal-1)]{.content-hidden unless-profile=\"book\"}: Typically, your \"zones\" will be vector polygons\n\n\n\n\n\n::: {.cell}\n\n:::\n\n\n\n## Zonal operations with vector data\n\n- The `zonal` function in `{terra}` can handle vector data: however, it requires `sf` objects to be converted to `terra`'s own vector format, called `SpatVector`. - The function `vect()` can be used to convert `sf` objects to `SpatVector` objects:\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_vals <- zonal(r, vect(zones), fun = mean, na.rm = TRUE)\n\n\nzones$mean <- mean_vals$elevation\n```\n:::\n\n\n\n\n::: {.cell .column-page layout-nrow=\"1\"}\n::: {.cell-output-display}\n![The original raster data](raster-vector-operations_files/figure-revealjs/fig-zonal-vector-1.png){#fig-zonal-vector-1 width=960}\n:::\n\n::: {.cell-output-display}\n![The original zones as vector polygons](raster-vector-operations_files/figure-revealjs/fig-zonal-vector-2.png){#fig-zonal-vector-2 width=960}\n:::\n\n::: {.cell-output-display}\n![The resulting zones (mean elevation per zone), also as vector data](raster-vector-operations_files/figure-revealjs/fig-zonal-vector-3.png){#fig-zonal-vector-3 width=960}\n:::\n:::\n\n\n\n## Extracting raster values at vector points\n\n- A another common operation is to extract raster values at specific points\n- Let's take the example of the city of Luxembourg (see @sec-global-2)\n- The function `extract()` can be used to extract raster values at specific points\n- `extract` returns a data.frame with \n  - one column per raster band (1 in our case)\n  - one row per point (also 1 in our case): \n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](raster-vector-operations_files/figure-revealjs/unnamed-chunk-5-1.png){width=960}\n:::\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlux_elev <- extract(r, luxembourg_city)\nlux_elev\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  ID elevation\n1  1  293.9805\n```\n\n\n:::\n:::\n\n\n\n## Vector to raster conversion\n\n- Functions that combine raster and vector data usually convert vector to raster internally\n- Sometimes, we might want to do this conversion explicitly. This can be done using the `rasterize()` function\n- This function takes three arguments:\n  1. `x`: The vector data (either of class `sf` or `SpatVector`)\n  2. `y`: A raster object that defines the extent, resolution, and CRS of the resulting raster (i.e. a \"template\")\n  3. `field`: The name of the column in the vector data that should be used to fill the raster cells\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# we can create a template using the input vector. All we have to specify \n# is the resolution of the output raster, which is evalutated in the units of\n# the CRS of the input vector data (meters in our case).\n\ntemplate <- rast(zones, resolution = 1000)\n\nzones_raster <- rasterize(zones, template, \"zone\")\n```\n:::\n\n\n\n\n::: {#fig-vector-to-raster .cell .column-page layout-nrow=\"1\"}\n::: {.cell-output-display}\n![The original zones as polygon data](raster-vector-operations_files/figure-revealjs/fig-vector-to-raster-1.png){#fig-vector-to-raster-1 width=960}\n:::\n\n::: {.cell-output-display}\n![The zones as raster data](raster-vector-operations_files/figure-revealjs/fig-vector-to-raster-2.png){#fig-vector-to-raster-2 width=960}\n:::\n\nNote how the conversion to polygons results in a loss of detail\n:::\n\n\n:::{.callout-note}\n\nNote that rasters don't store character information. The above *zones* are coded as integers with a corresponding look-up table (see `?terra::levels`).\n\n:::\n\n\n## Raster to vector conversion\n\n\n- The opposite operation, converting raster data to vector data, can be done using the `{terra}` functions `as.points`, `as.lines` and `as.polygons`:\n- The resulting object will be of class `SpatVector`. This can be converted to the `sf` class using `st_as_sf()`\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nzones_poly <- as.polygons(zones_raster) |> \n  st_as_sf()\n```\n:::\n\n\n\n::: {#fig-raster-to-vector .cell .column-page layout-nrow=\"1\"}\n::: {.cell-output-display}\n![The zones as raster data](raster-vector-operations_files/figure-revealjs/fig-raster-to-vector-1.png){#fig-raster-to-vector-1 width=960}\n:::\n\n::: {.cell-output-display}\n![The zones as polygon data](raster-vector-operations_files/figure-revealjs/fig-raster-to-vector-2.png){#fig-raster-to-vector-2 width=960}\n:::\n\nNote how the conversion back to polygons preserves the cell boundaries\n:::\n\n\n\n\n\n## ðŸª• Tasks\n\n\n1. Import `Arealstatistik.gpkg` from *Spatial_Analysis_II* using `{sf}`\n2. To rasterize the data, we need a template raster object. Create a template raster object with a resolution of 100m using the `rast()` function\n3. Rasterize the arealstatistik data using the function `rasterize`, the tempalte from the previous step, and the column `AS_4` as the field to fill the raster cells\n\n\n\n::: {.cell}\n\n:::\n\n\n\n4. The resulting raster contains the integer values 1 to 4. These values correspond to the following land use categories (see [metadata](https://www.bfs.admin.ch/asset/en/1420906)):\n   1. Settlement and urban areas\n   2. Agricultural areas\n   3. Wooded areas\n   4. Unproductive areas\n\nTo make the raster more interpretable, assign the corresponding names to the levels of the raster using the `levels()` function. The levels should be a data.frame with two columns: `ID` and `name` (see below)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlevs <- data.frame(\n  ID = 1:4, \n  name = c(\n    \"Settlement and urban areas\", \n    \"Agricultural areas\", \n    \"Wooded areas\", \n    \"Unproductive areas\"\n    ) \n  )\n\nlevels(areal_rast) <- levs\n\nplot(areal_rast)\n```\n\n::: {.cell-output-display}\n![](raster-vector-operations_files/figure-revealjs/unnamed-chunk-10-1.png){width=960}\n:::\n:::\n\n\n\n\n\n\n\n\n",
    "supporting": [
      "raster-vector-operations_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}