{
  "hash": "cb201bb81934f5b1cee1163c3d2729f6",
  "result": {
    "engine": "knitr",
    "markdown": "---\necho: false\n---\n\n\n\n\n# Raster Operations\n\n## Introduction\n\n- Map algebra can be defined as operations that modify or summarize raster cell values, with reference to surrounding cells, zones, or statistical functions that apply to every cell.\n- Map algebra divides raster operations into four subclasses:\n  1. **Local** or per-cell operations\n  2. **Focal** or neighborhood operations. Most often the output cell value is the result of a 3 x 3 input cell block\n  3. **Zonal** operations are similar to focal operations, but the surrounding pixel grid on which new values are computed can have irregular sizes and shapes\n  4. **Global** or per-raster operations. That means the output cell derives its value potentially from one or several entire rasters\n\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n\n\n\n\n## Global Operation (1)\n\n- The most common global operations are descriptive statistics for the entire raster dataset such as the minimum, maximum or mean value. \n- For example: What is the mean elevation value for Luxembourg?\n\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![Elevation of Luxembourg](raster-operations_files/figure-html/fig-elev-1.png){#fig-elev width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# note: mean(r) does not work, since \"mean\" is used as a local operator\nmean_elev <- global(r, mean, na.rm = TRUE)\n\nmean_elev\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n              mean\nelevation 347.6488\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Global Operation (2) {#sec-global-2}\n\n- Another type of \"global\" operation is `distance`\n- This function calculates the distance from each cell to a specific target cell\n- For example, what is the distance from each cell to *Luxembourg City*, the capital of Luxembourg?\n\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n![](raster-operations_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nr_dist <- distance(r, luxembourg_city)\nr_dist <- mask(r_dist, r)\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](raster-operations_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n## Zonal {#sec-zonal-1}\n\n- Zonal operations apply an aggregation function to multiple raster cells\n- A second raster with categorical values define the \"zones\"\n\nWhat is the mean altitude *per municipality*?\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmean_vals <- zonal(r, zones, fun = mean, na.rm = TRUE)\n```\n:::\n\n::: {.cell .column-page layout-nrow=\"1\"}\n::: {.cell-output-display}\n![The original Zones (E.g. municipalities of Luxembourg)](raster-operations_files/figure-html/fig-zonal-1.png){#fig-zonal-1 width=672}\n:::\n\n::: {.cell-output-display}\n![Mean elevation per zone / per municipality](raster-operations_files/figure-html/fig-zonal-2.png){#fig-zonal-2 width=672}\n:::\n:::\n\n\n\n\n\n:::{.callout-note collapse=\"true}\n\n- The global operation can be seen as a special case of a zonal operation, where the only \"Zone\" is the entire dataset\n\n\n:::\n\n## Local (1)\n\n- Local operations comprise all cell-by-cell operations in one or several layers.\n- For example, we can classify the elevation into values above and below a certain threshold\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# first, create a boolean copy of the raster\nr_bool <- as.logical(r)\n\nmean_elev <- as.numeric(mean_elev)\nmean_elev\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 347.6488\n```\n\n\n:::\n\n```{.r .cell-code}\nr_bool[r > mean_elev] <- FALSE\nr_bool[r <= mean_elev] <- TRUE\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](raster-operations_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n\n## Local (2)\n\n- This type of (re-) classification is a very common operation\n- For more than 2 categories, we can use `classify`\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncuts <- global(r, quantile, probs = c(0, .33, .66, 1), na.rm = TRUE)\n\nr_classify <- classify(r, as.numeric(cuts))\n\n# this next line just replaces the default labels with some custom ones\nlevels(r_classify) <- data.frame(ID = 0:2, category = c(\"low\",\"mid\",\"high\"))\n\np + tm_shape(r_classify) +\n    tm_raster(style = \"cat\",legend.show = TRUE, palette = \"viridis\", title = \"Elevation\") +\n    tm_layout(legend.show = TRUE)\n```\n\n::: {.cell-output-display}\n![](raster-operations_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n## Local (3)\n\n- Local operations are often used with multiple bands\n- For example, we could calculate the mean intensity values of red, green and blue:\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nl7 <- rast(system.file(\"tif/L7_ETMs.tif\",package = \"stars\"))\n\nnames(l7) <- c(\"B\", \"G\", \"R\", \"NIR\", \"SWIR\", \"MIR\")\n\nl7_rgb <- l7[[c(\"R\",\"G\", \"B\")]]\n\nplot(l7_rgb, nr = 1)\n```\n\n::: {.cell-output-display}\n![](raster-operations_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nl7_rgb_mean <- mean(l7_rgb)\n\nplot(l7_rgb_mean)\n```\n\n::: {.cell-output-display}\n![](raster-operations_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Local (4)\n\n- In a more complex usecase, we could use the R, G and B band to calculate a grayscale value ($L^*$) using the following formula (from [here](https://stackoverflow.com/a/689547/4139249)):\n\n\\begin{aligned}\n\nL^* &= 116 \\times Y ^ {\\frac{1}{3}} - 16\\\\\n\nY &= 0.2126 \\times R^\\gamma+0.7152 \\times G^\\gamma+0.0722 \\times B^\\gamma \\\\\n\n\n\\gamma &= 2.2\n\n\\end{aligned}\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\ng <- 2.2\n\nl7 <- l7/255 # scale values to 0-1 (probabbly not necessary)\n\nY <- 0.2126 * l7[[\"R\"]]^g + 0.7152 * l7[[\"G\"]]^g + 0.0722 * l7[[\"B\"]]^g\n\nL <- 116* Y^(1/3)-16\n\n# Plot the result\n```\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![](raster-operations_files/figure-html/unnamed-chunk-18-1.png){width=672}\n:::\n:::\n\n\n\n\n\n\n## Focal {#sec-focal-1}\n\n- While local functions operate on one cell focal operations take into account a central (focal) cell *and its neighbors*. \n- The neighborhood (also named kernel, filter or moving window) under consideration is typically of size 3-by-3 cells (that is the central cell and its eight surrounding neighbors), but can take on any other size or shape as defined by the user. \n- A focal operation applies an aggregation function to all cells within the specified neighborhood, uses the corresponding output as the new value for the central cell, and moves on to the next central cell\n\n\n:::{#fig-focal}\n\n![](images/focal.png)\n\nNote how, depending on the size of your moving window, NA's are produced. Source: @lovelace2019\n:::\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfocal3by3 <- matrix(rep(1,9), ncol = 3)\n\n\nfocal11by11 <- matrix(rep(1,121), ncol = 11)\n\n\nr_foc3 <- focal(r, focal3by3, fun = mean, fillNA = TRUE)\n\nr_foc11 <- focal(r, focal11by11, fun = mean, fillNA = TRUE)\n```\n:::\n\n::: {.cell .column-page layout-nrow=\"1\"}\n::: {.cell-output-display}\n![Original values](raster-operations_files/figure-html/fig-focal2-1.png){#fig-focal2-1 width=672}\n:::\n\n::: {.cell-output-display}\n![Result of a 3x3 Focal Window](raster-operations_files/figure-html/fig-focal2-2.png){#fig-focal2-2 width=672}\n:::\n\n::: {.cell-output-display}\n![Result of a 11x11 Focal Window](raster-operations_files/figure-html/fig-focal2-3.png){#fig-focal2-3 width=672}\n:::\n:::\n\n\n\n\n\n:::{.callout-note collapse=\"true\"}\n\n- Note how the output raster is smaller as the focal window is larger (edge effect)\n\n:::\n\n## Focal weights (1)\n\n- The focal weights we used above were square and evenly weighted\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfocal3by3\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    1    1\n[2,]    1    1    1\n[3,]    1    1    1\n```\n\n\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfocal11by11\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10] [,11]\n [1,]    1    1    1    1    1    1    1    1    1     1     1\n [2,]    1    1    1    1    1    1    1    1    1     1     1\n [3,]    1    1    1    1    1    1    1    1    1     1     1\n [4,]    1    1    1    1    1    1    1    1    1     1     1\n [5,]    1    1    1    1    1    1    1    1    1     1     1\n [6,]    1    1    1    1    1    1    1    1    1     1     1\n [7,]    1    1    1    1    1    1    1    1    1     1     1\n [8,]    1    1    1    1    1    1    1    1    1     1     1\n [9,]    1    1    1    1    1    1    1    1    1     1     1\n[10,]    1    1    1    1    1    1    1    1    1     1     1\n[11,]    1    1    1    1    1    1    1    1    1     1     1\n```\n\n\n:::\n:::\n\n\n\n\n\n\n## Focal weights (2)\n\n- However, we can also create uneven weights:\n\n\n\nFor example, a [laplacian filter](https://de.wikipedia.org/wiki/Laplace-Filter) is commonly used for edge detection.\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlaplacian <- matrix(c(0,1,0,1,-4,1,0,1,0), nrow=3) \n\nlaplacian\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    0    1    0\n[2,]    1   -4    1\n[3,]    0    1    0\n```\n\n\n:::\n:::\n\n\n\n\n\nSo are the [sobel filters](https://en.wikipedia.org/wiki/Sobel_operator)\n\n\n\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]   -1    0    1\n[2,]   -2    0    2\n[3,]   -1    0    1\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n     [,1] [,2] [,3]\n[1,]    1    2    1\n[2,]    0    0    0\n[3,]   -1   -2   -1\n```\n\n\n:::\n:::\n\n::: {.cell .column-page layout-nrow=\"1\"}\n::: {.cell-output-display}\n![Laplacian Filter](raster-operations_files/figure-html/fig-edgedetection-1.png){#fig-edgedetection-1 width=672}\n:::\n\n::: {.cell-output-display}\n![Sobel (x-direction)](raster-operations_files/figure-html/fig-edgedetection-2.png){#fig-edgedetection-2 width=672}\n:::\n\n::: {.cell-output-display}\n![SObel (y-direction)](raster-operations_files/figure-html/fig-edgedetection-3.png){#fig-edgedetection-3 width=672}\n:::\n:::\n\n\n\n\n\n\n## Focal weights (3)\n\n\n- We can also create specific *shapes* using weights\n- We don't need to create these matrices by hand. Rather, we can use the function `focalMat` to create different shapes automatically\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note \n# - \"d\" is evaluated in the units of \"x\" (in our case: meters)\n# - The sum of all weights equals to 1\n# - Note how the edges receive a value of 0\nfocal_circle3000 <- focalMat(x = r, d = 3000, \"circle\")\n\nfocal_circle3000\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           [,1]       [,2]       [,3]       [,4]       [,5]\n[1,] 0.00000000 0.00000000 0.03703704 0.00000000 0.00000000\n[2,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[3,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[4,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[5,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[6,] 0.03703704 0.03703704 0.03703704 0.03703704 0.03703704\n[7,] 0.00000000 0.00000000 0.03703704 0.00000000 0.00000000\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![A visual representation of the matrix / filter above](raster-operations_files/figure-html/unnamed-chunk-27-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nfocal_gauss1000 <- focalMat(x = r, d = 1000, \"Gauss\")\n\nfocal_gauss1000\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            [,1]        [,2]        [,3]        [,4]        [,5]\n[1,] 0.000241551 0.001082556 0.001784834 0.001082556 0.000241551\n[2,] 0.002942693 0.013188236 0.021743725 0.013188236 0.002942693\n[3,] 0.013188236 0.059105572 0.097448614 0.059105572 0.013188236\n[4,] 0.021743725 0.097448614 0.160665602 0.097448614 0.021743725\n[5,] 0.013188236 0.059105572 0.097448614 0.059105572 0.013188236\n[6,] 0.002942693 0.013188236 0.021743725 0.013188236 0.002942693\n[7,] 0.000241551 0.001082556 0.001784834 0.001082556 0.000241551\n```\n\n\n:::\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![A visual representation of the matrix / filter above](raster-operations_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n\n\n\n\n## Focal functions in terrain processing\n\n- Focal functions are used to calculate the slope of a specific location, e.g. using the algorithm by @horn1981\n- Similarly, calculating the aspect (azimuth) of a location is a very typical task when dealing with elevation data\n- These algorithms are used so often, that they are implemented in a dedicated function (`terrain()`)\n\n\n\n\n\n::: {.cell .column-page layout-nrow=\"1\"}\n\n```{.r .cell-code}\nterrain(r, \"slope\") |> plot()\nterrain(r, \"aspect\") |> plot()\n```\n\n::: {.cell-output-display}\n![Calculating slope using a predefined algorithm](raster-operations_files/figure-html/fig-terrain-1.png){#fig-terrain-1 width=672}\n:::\n\n::: {.cell-output-display}\n![Calculating aspect](raster-operations_files/figure-html/fig-terrain-2.png){#fig-terrain-2 width=672}\n:::\n:::\n\n\n\n\n\n\n## 🪕 Tasks\n\n\n1. Import the elevation of Luxembourg using the following code:\n\n\n\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code}\n   r <- rast(system.file(\"ex/elev.tif\", package=\"terra\"))\n   ```\n   :::\n\n\n\n\n\n2. Calculate the mean, maximum and minimum elevation values\n\n3. Calculate slope and aspect (see [terrain functions](https://rspatial.github.io/terra/reference/terrain.html))\n\n4. Determine suitable locations of solar panels using the following conditions:\n   - Elevation: above 300 MASL\n   - Slope: Between 1 and 3° \n   - Aspect: Southfacing (between 135 and 235°)\n   \n\n5. Download the Municipalities of Luxembourg from Moodle and calculate the minimum, maximum and mean elevation values per municipality.\n\n6. Smooth the elevation values using different focal windows\n\n7. Import the multispectral Landsat 7 as a raster using the following path\n\n\n\n\n\n   ::: {.cell}\n   \n   ```{.r .cell-code}\n   system.file(\"tif/L7_ETMs.tif\",package = \"stars\")\n   ```\n   :::\n\n\n\n\n\n8. Calculate the [NDVI](https://en.wikipedia.org/wiki/Normalized_difference_vegetation_index) using the following formula:\n\n$$\\text{NDVI} = \\frac{\\text{NIR}-\\text{red}}{\\text{NIR}+\\text{red}}$$\n\n\n\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![The resulting NDVI values](raster-operations_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "raster-operations_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}