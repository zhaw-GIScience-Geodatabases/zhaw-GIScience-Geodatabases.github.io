{
  "hash": "35bc186abff1460f03d971022cbee920",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Vector data I/O\nexecute: \n  echo: true\n---\n\n\n- The library `{sf}` can import data from various sources:\n  1. A multitude of file formats from disk (powered `gdal` / `ogr2ogr`)\n  2. Various geospatial databases such as `PostGIS` \n  3. From other sources (such as `WKT`, `WKB` other geospatial R-libraires)\n- We will only introduce the first method, since this is the most common use case\n\n## GDAL / ogr2ogr {#sec-gdal-ogr2ogr}\n\nGDAL:\n\n- is an open source translator library for raster and vector geospatial data formats.\n- stands for Geospatial Data Abstraction Library\n- is used [in most geospatial software](https://gdal.org/en/latest/software_using_gdal.html#software-using-gdal), be it FOSS or proprietary. The list includes: ArcGIS, QGIS, R (`sf`) and Python (`geopandas`)\n  \n  \n## GDAL Vector drivers (read)\n\n- Since GDAL supports [a long list](https://gdal.org/en/latest/drivers/vector/index.html) of different geospatial file formats, most (all?) are in turn supported by `{sf}`\n- Run the function `st_drivers` for a full list\n- `{sf}` tries to guess the correct driver based on the file extension (see below)\n\n\n\n::: {.cell}\n\n:::\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sf uses the geojson driver, based on the file extension\n# (data from moodle â†’  Spatial Databases II â†’ Database Files)\nstationen_schweiz <- read_sf(\"data/uebung1/stationen_schweiz.geojson\")\n```\n:::\n\n\n[]{}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# sf uses the shapefile driver, based on the file extension\n# (data from moodle â†’  Spatial Analysis I â†’ Exercise Data) \nhoheitsgebiet <- read_sf(\"data/Spatial_Analysis_I/Hoheitsgebiet/HOHEITSGEBIET_FR.shp\")\n```\n:::\n\n\n\n## Multiple layers in one file\n\n- Some file formats, e.g. Geopackages (\\*.gpkg) or Geodatabases (\\*.gdb) support multiple datasets in a single file. \n- If no specific layer is requested `read_sf()` will import the first available layer\n- If more than 1 layers are available, `read_sf()` will return a warning\n- The function `st_layers()` will list all available layers\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntlm3d_path <- \"data/Spatial_Analysis_II/swiss_TLM3D.gpkg\"\n\n# Note the warning:\ntlm3d <- read_sf(tlm3d_path)\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in CPL_read_ogr(dsn, layer, query, as.character(options), quiet, :\nautomatically selected the first layer in a data source containing more than\none.\n```\n\n\n:::\n:::\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# This will list all layers, including some metadata\nst_layers(tlm3d_path)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nDriver: GPKG \nAvailable layers:\n    layer_name        geometry_type features fields       crs_name\n1       tlm_bb     3D Multi Polygon    49321     13 CH1903+ / LV95\n2 tlm_strassen 3D Multi Line String   191644     27 CH1903+ / LV95\n```\n\n\n:::\n:::\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# To import a single layer\ntlm_bb <- read_sf(tlm3d_path, \"tlm_bb\")\n```\n:::\n\n\n\n## SQL queries during import\n\n\n- `read_sf()` can parse a (spatialite) SQL query provided in the `query = ` argument\n- In case `query = ` is used, the `layers = ` argument should be skipped (since the layers is specified in the query)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntlm_seen <- read_sf(\n  tlm3d_path, \n  query = \"SELECT objektart, geom FROM tlm_bb WHERE objektart = 'Stehende Gewaesser'\"\n  )\n```\n:::\n\n\n\n\n## GDAL Vector drivers (write)\n\n- The function `st_write()` is used to export an `sf` object to file\n- Most vector drivers support reading *and writing* (see `st_drivers` / column `write`)\n- Many file formats support appending to the dataset (see `append = `)\n\n\n\n::: {.cell}\n\n:::\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\nst_write(tlm_seen, \"data-out/seen.geojson\")\n```\n:::\n\n\n## ðŸª• Tasks\n\n1. Import the datasets from Spatial Analysis I and II using R\n2. Explore these datasets by printing the `sf` objects to the console\n3. Try different visualization methods [(see @sec-plotting)]{.content-hidden unless-profile=\"book\"}\n\n\n\n\n<!-- todo: reading / writing spatial databases -->\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}