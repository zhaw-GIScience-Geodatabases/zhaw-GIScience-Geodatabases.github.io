{
  "hash": "859490bca178ef891bc5616a1a956a3a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Spatial Vector Operation\nexecute: \n  echo: true\n---\n\n\n::: {.cell}\n\n:::\n\n\n\n\n## Thematic queries\n\n[]{.lts .content-hidden unless-profile=\"book\"}\n\n\n- SQL queries can be performed with file import\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntlm3d_path <- \"data/Spatial_Analysis_II/swiss_TLM3D.gpkg\"\n\ntlm_seen <- read_sf(\n  tlm3d_path, \n  query = \"SELECT objektart, geom FROM tlm_bb WHERE objektart = 'Stehende Gewaesser'\"\n  )\n```\n:::\n\n\n---\n\n- However, datasets can also be queried after import using `data.frame` methods (such as `[` or `dplyr::filter`)\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntlm_bb <- read_sf(tlm3d_path, \"tlm_bb\")\n\n# Subsetting with base-R\ntlm_seen <- tlm_bb[tlm_bb$objektart == \"Stehende Gewaesser\", ]\n\n# Subsetting using dplyr::filter\ntlm_seen <- filter(tlm_bb, objektart == \"Stehende Gewaesser\")\n```\n:::\n\n\n\n## Spatial queries using binary predicate functions\n\nTake the following example:\n\n> Select all forests in the canton of Luzern\n\n- Spatial query functions include: `st_contains()`, `st_contains()`, `st_contains()`, `st_contains()`, and many more\n- These spatial queries are called [geometric binary predicates](https://r-spatial.github.io/sf/reference/geos_binary_pred.html) \n\n---\n\n- This family of functions return so called *sparse matrices*: a `list` the same length as `x`, which, for each element in `x`, contains the indices of `y` where the condition is met. For example:\n- They *could* return cross matrices, but these usually have a larger memory, since they have are $x \\times y$ in size\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nluzern <- read_sf(\"data/Spatial_Analysis_II/swissBOUNDARIES3D.gpkg\")\n\ntlm_wald <- filter(tlm_bb, objektart == \"Wald\")\n\n# The dataset already has this crs (2056), but apparently \n# does not realize this\ntlm_wald <- st_set_crs(tlm_wald, 2056)\n\n\nquery_res <- st_intersects(tlm_wald, luzern)\n```\n:::\n\n\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note the length of the output equals nrow(tlm_wald)\nquery_res\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSparse geometry binary predicate list of length 8096, where the\npredicate was `intersects'\nfirst 10 elements:\n 1: (empty)\n 2: (empty)\n 3: (empty)\n 4: (empty)\n 5: (empty)\n 6: (empty)\n 7: (empty)\n 8: (empty)\n 9: (empty)\n 10: (empty)\n```\n\n\n:::\n:::\n\n\n\n- (The first 10 elements are empty, because these are not within Luzern)\n- This list can be used to subset `x` (`TRUE` where the list is not empty):\n\n\n---\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Note the use of lenghts (with an s) to get the length of each element in the \n# list\nwald_luzern <- tlm_wald[lengths(query_res) > 0,]\n\n\nggplot(luzern) + \n  geom_sf(data = wald_luzern, fill = \"darkgreen\") +\n  geom_sf(color = \"red\", fill = NA) \n```\n\n::: {.cell-output-display}\n![Note how some forests are outside the canton's border. This is the nature of `st_intersects`. If even a small part of a forest feature is within Luzern, this feature *intersects* Luzern and is therefore retained. To query only forests that are *completly* within Luzern, use `st_within()`.](spatial-operations_files/figure-html/fig-intersects-1.png){#fig-intersects width=672}\n:::\n:::\n\n\n\n## Spatial queries using `[` or `st_filter`\n\n- The code above was for illustration purposes. The code can be written more concise: \n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# using sf-methods in base-R\ntlm_wald[luzern,, op = st_intersects]\n\n# using st_filter\nst_filter(tlm_wald, luzern, .predicate = st_intersects)\n```\n:::\n\n\n- The default value for `op` and .predicate is `st_intersects`, so these arguments could also have been omitted\n\n\n## Overlay Analysis\n\n\n- In the example illustrated in @fig-intersects, we have the choice of subsetting forests that either intersect Luzern ever so slightly (`st_intersects`), or that lie *completely* within Luzern (`st_within`). \n- Depending on the question, both options can be unsatisfactory (e.g. if the question was *Which percentage of Luzern is covered by forest?*)\n- For some cases, it might be necessary to \"cut\" the forest area at the cantons border\n\n---\n\n- This can be achieved with `st_intersection` (which is different from `intersects`)\n- There are several other functions that work on pairs of geometries. See  [Geometric operations on pairs of simple feature geometry sets](https://r-spatial.github.io/sf/reference/geos_binary_ops.html)\n- There are even more functions that work on single geometries, e.g. `st_buffer`. See [Geometric unary operations on simple feature geometry sets](https://r-spatial.github.io/sf/reference/geos_unary.html)\n\n\n---\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(glue)\nlibrary(scales)\nwald_luzern2 <- st_intersection(luzern, wald_luzern)\n\nggplot(luzern) + \n  geom_sf(fill = \"gray\", color = NA) +\n  geom_sf(data = wald_luzern2, fill = \"darkgreen\", color = NA)\n```\n\n::: {.cell-output-display}\n![](spatial-operations_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n---\n\n- Now, it's possible to compute the area of Luzern and the forest that *intersects* Luzern using the function `st_area`.\n- There are several functions to [compute geometric measurements](https://r-spatial.github.io/sf/reference/geos_measures.html) of `sf`-objects.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsum(st_area(wald_luzern2))/st_area(luzern)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n0.2721733 [1]\n```\n\n\n:::\n:::\n\n\n\n<!-- todo: add buffer, union, dissolve -->\n\n## ðŸª• Tasks\n\n\nFrom the exercise in **Spatial Analysis I**, solve the following tasks using R:\n   \n- Task 2: Thematic Selections (Select by Attributes)\n- Task 3: Exporting Selected Features to a New ~~Layer~~ `sf` object\n- Task 6: Intersect (Intersection)\n- Task 8: Buffer\n- Task 9: Spatial Selection (Select by Location)\n\n\n\n\n\n",
    "supporting": [
      "spatial-operations_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}